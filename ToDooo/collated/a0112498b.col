//@author: a0112498b



	/**
	 * origin: C:\Users\Ruyi\Desktop\collate\source\application\Command.java
	 */

package application;

import java.util.Date;

public enum Command {
	ADD("add", "-a"),
	DELETE("delete", "-d"),
	UPDATE("update", "-u"),
	SEARCH("search", "-s"),
	COMPLETE("complete", "-c"),
	UNCOMPLETE("uncomplete", "-uc"),
	VIEW("view", "-v"),
	FROM("/from", "-f"),
	TO("/to", "-t"),
	ON("/on", "-o"),
	BY("/by", "-b"),
	CATEGORY("#", "#"),
	PRIORITY_HIGH("/high", "/***"),
	PRIORITY_MEDIUM("/medium", "/**"),
	PRIORITY_LOW("/low", "/*"),
	RECURRING_DAILY("/daily", "-day"),
	RECURRING_WEEKLY("/weekly", "-w"),
	RECURRING_MONTHLY("/monthly", "-m"),
	RECURRING_YEARLY("/yearly", "-y"),
	RECURRING_UNTIL("/until", "-u");
	
	private final String _COMMAND_BASIC;
	private final String _COMMAND_ADVANCED;
	
	// -----------------------------------------------------------------------------------------------
	// Constructor
	// -----------------------------------------------------------------------------------------------		
	private Command(String commandBasic, String commandAdvanced) {
		_COMMAND_BASIC = commandBasic;
		_COMMAND_ADVANCED = commandAdvanced;
	}
	
	// -----------------------------------------------------------------------------------------------
	// Get methods
	// -----------------------------------------------------------------------------------------------
	public String getBasicCommand() {
		return _COMMAND_BASIC;
	}
	
	public String getAdvancedCommand() {
		return _COMMAND_ADVANCED;
	}
		
	// -----------------------------------------------------------------------------------------------
	// Public methods
	// -----------------------------------------------------------------------------------------------
	public static Command verifyCrudCommands(String commandLine) {		
		for (Command command : Constant.COMMAND_ACTIONS) {
			
			if (command.hasActionCommand(commandLine)) {				
				return command;
			}
		}		
		return Command.ADD;
	}

	/*
	 * Returns recurring command if: 
	 * 1) has the correct recurring command e.g. /weekly /until
	 */
	public static Command verifyRecurringCommands(String commandLine) {				
		for (Command recurringCommand : Constant.COMMAND_RECURRING) {
			if (recurringCommand.hasValidRecurringCommand(commandLine)) {
				return recurringCommand;
			}
		}
		
		return null;
	}
	
	/*
	 * Returns true if:
	 * 1) commandLine has either /weekly, /monthly or /yearly
	 */
	public static boolean hasRecurringCommands(String commandLine) {			
		boolean hasFound = false;
		
		for (Command recurringCommand : Constant.COMMAND_RECURRING) {
			if (recurringCommand.hasCommand(commandLine)) {
				hasFound = true;
			}
		}
		
		return hasFound;
	}
			
	/*
	 * Returns true if:
	 * 1) has category command #
	 * 2) category name behind # is not empty
	 */
	public static boolean hasCategoryCommand(String commandLine) {
		String lowerCase = commandLine.toLowerCase() + " ";
		String basicCmd = Command.CATEGORY.getBasicCommand();
		boolean isCategorised = false;
		int beginIndex = -1;
		int endIndex = -1;
		
		if (lowerCase.contains(basicCmd)) {
			beginIndex = lowerCase.indexOf(basicCmd);
			endIndex = beginIndex + basicCmd.length();
			
			if (lowerCase.charAt(endIndex) != ' ') {
				isCategorised = true;
			}
		}
				
		return isCategorised;
	}
			
	public static boolean hasValidNumOfDateCommands(String commandLine) {
		int count = 0;
		boolean isCorrectNum = false;
		boolean isValidTimed = true;
		
		if (TaskType.isFloatingTask(commandLine)) {
			isCorrectNum = true;
			
			return isCorrectNum;
		}
		
		for (Command command : Constant.COMMAND_DATES) {
			if (command.hasCommand(commandLine)) {
				isValidTimed = !(((command.name().equals(Command.FROM) || 
								   command.name().equals(Command.TO)) && 
								   count >= Constant.MAX_NUM_OF_FROM_TO_DATES) ||
						 		(!(command.name().equals(Command.FROM) || 
						 		   command.name().equals(Command.TO)) && 
						 		   count >= Constant.MAX_NUM_OF_DATE_IN_COMMAND));
				
				count++;
			}
		}
		
		if (count == Constant.MAX_NUM_OF_DATE_IN_COMMAND || 
		   (count == Constant.MAX_NUM_OF_FROM_TO_DATES && isValidTimed)) {
			isCorrectNum = true;
		}
		
		return isCorrectNum;
	}
	
	public static boolean shouldRetrieveOriginalInput(String commandLine) {		
		boolean shouldRetrieve = false;
		
		boolean hasNoUpdateDelimiter = 
				(commandLine.indexOf(Constant.DELIMITER_UPDATE) == -1);
		
		if (hasNoUpdateDelimiter) {
			shouldRetrieve = true;
		}
		
		return shouldRetrieve;
	}
	
	public int getIndexOfCommand(String commandLine) {
		String lowerCase = commandLine.toLowerCase() + " ";
		String basicCmd = _COMMAND_BASIC + " ";
		String advancedCmd = _COMMAND_ADVANCED + " ";
		int endIndex = -1;
				
		if (lowerCase.contains(basicCmd)) {
			endIndex = lowerCase.indexOf(basicCmd);				
		} else if (lowerCase.contains(advancedCmd)) {
			endIndex = lowerCase.indexOf(advancedCmd);
		} 
		
		return endIndex;
	}
		
	// -----------------------------------------------------------------------------------------------
	// Private methods
	// -----------------------------------------------------------------------------------------------
	private boolean hasCommand(String commandLine) {
		String lowerCase = commandLine.toLowerCase() + " ";
		String basicCmd = _COMMAND_BASIC + " ";
		String advancedCmd = _COMMAND_ADVANCED + " ";
				
		
		return (lowerCase.contains(basicCmd) ||
				lowerCase.contains(advancedCmd));
	}
	
	private boolean hasActionCommand(String commandLine) {
		int startIndex = 0;
		String lowerCase = commandLine.toLowerCase();
		String basicCmd = _COMMAND_BASIC + " ";
		String advancedCmd = _COMMAND_ADVANCED + " ";
		
		return (lowerCase.indexOf(basicCmd) == startIndex ||
			    lowerCase.indexOf(advancedCmd) == startIndex);
	}
	
	private boolean hasValidRecurringCommand(String commandLine) {
		String lowerCase = commandLine.toLowerCase() + " ";
		String basicCmd = _COMMAND_BASIC + " " + 
						  Command.RECURRING_UNTIL.getBasicCommand() + " ";
		String advancedCmd = _COMMAND_ADVANCED + " " + 
						  	 Command.RECURRING_UNTIL.getAdvancedCommand() + " ";
		int beginIndex = -1;
		int endIndex = lowerCase.length();
		
		if (lowerCase.contains(basicCmd)) {
			beginIndex = lowerCase.indexOf(basicCmd);
		} else if (lowerCase.contains(advancedCmd)) {
			beginIndex = lowerCase.indexOf(advancedCmd);
		}
				
		boolean hasRecurringCommand = (beginIndex != -1);
		if (hasRecurringCommand) {
			lowerCase = lowerCase.substring(beginIndex, endIndex);
			
			Date untilDate = Main.inputParser.getDateFromString(lowerCase);
			if (untilDate != null) {
				hasRecurringCommand = true;
			} else {
				hasRecurringCommand = false;
			}
		}
		
		return hasRecurringCommand;
	}
}

	// End of segment: C:\Users\Ruyi\Desktop\collate\source\application\Command.java





	/**
	 * origin: C:\Users\Ruyi\Desktop\collate\source\application\DateParser.java
	 */

	public static Calendar createCalendar(Date date) {
		Calendar calendar = Calendar.getInstance();
		calendar.setTimeZone(TimeZone.getDefault());
		calendar.setTime(date);
		
		return calendar;
	}
	
	public static Calendar getTodayCalendar() {
		Calendar calendar = Calendar.getInstance();
		calendar.setTimeZone(TimeZone.getDefault());
		
		return calendar;
	}
	
	public static int calculateDayOfWeek(Date date) {
		Calendar calendar = DateParser.createCalendar(date);
		int dayOfWeek = calculateDayOfWeek(calendar);
		
		return dayOfWeek;
	}
	
	public static int calculateDayOfWeek(Calendar calendar) {
		int dayOfWeek = calendar.get(Calendar.DAY_OF_WEEK);
		
		return dayOfWeek;
	}	
	
	public static int calculateDayOfMonth(Date date) {
		Calendar calendar = DateParser.createCalendar(date);
		int dayOfMonth = calculateDayOfMonth(calendar);
		
		return dayOfMonth;
	}
	
	public static int calculateDayOfMonth(Calendar calendar) {
		int dayOfMonth = calendar.get(Calendar.DAY_OF_MONTH);
		
		return dayOfMonth;
	}
	
	public static int calculateMonth(Date date) {
		Calendar calendar = DateParser.createCalendar(date);
		int month = calculateMonth(calendar);
		
		return month;
	}
	
	public static int calculateMonth(Calendar calendar) {
		int month = calendar.get(Calendar.MONTH);
		
		return month;
	}
	
	public static boolean isBeforeNow(Date date) {
		Calendar calendar = DateParser.createCalendar(date);
		
		return isBeforeNow(calendar);
	}
	
	public static boolean isBeforeNow(Calendar calendar) {
		Calendar nowCalendar = DateParser.getTodayCalendar();
		
		return calendar.before(nowCalendar);
	}
	
	public static boolean isAfterNow(Date date) {
		Calendar calendar = DateParser.createCalendar(date);
		
		return isAfterNow(calendar);
	}
	
	public static boolean isAfterNow(Calendar calendar) {
		Calendar nowCalendar = DateParser.getTodayCalendar();
		
		return calendar.after(nowCalendar);
	}
	
	public static boolean isBeforeDate(Date thisDate, Date thatDate) {
		Calendar calendarA = DateParser.createCalendar(thisDate);
		Calendar calendarB = DateParser.createCalendar(thatDate);
				
		return isBeforeDate(calendarA, calendarB);
	}
	
	public static boolean isBeforeDate(Calendar thisCalendar, Calendar thatCalendar) {				
		return thisCalendar.before(thatCalendar);
	}
	
	public static boolean isAfterDate(Date thisDate, Date thatDate) {
		return DateParser.isBeforeDate(thatDate, thisDate);
	}
	
	public static boolean isAfterDate(Calendar thisCalendar, Calendar thatCalendar) {
		return DateParser.isBeforeDate(thatCalendar, thisCalendar);
	}
	
	public static boolean hasMatchedDateOnly(Date thisDate, Date thatDate) {
		Calendar calendarA = DateParser.createCalendar(thisDate);
		Calendar calendarB = DateParser.createCalendar(thatDate);
		
		return DateParser.hasMatchedDateOnly(calendarA, calendarB);
	}
	
	public static boolean hasMatchedDateOnly(Calendar thisCalendar, Calendar thatCalendar) {
		return (thisCalendar.get(Calendar.ERA) == thatCalendar.get(Calendar.ERA) &&
				thisCalendar.get(Calendar.YEAR) == thatCalendar.get(Calendar.YEAR) &&
				thisCalendar.get(Calendar.DAY_OF_YEAR) == thatCalendar.get(Calendar.DAY_OF_YEAR));
	}
	
	public static boolean hasMatchedDateTime(Date thisDate, Date thatDate) {
		Calendar calendarA = DateParser.createCalendar(thisDate);
		Calendar calendarB = DateParser.createCalendar(thatDate);
		
		return DateParser.hasMatchedDateTime(calendarA, calendarB);
	}
	
	public static boolean hasMatchedDateTime(Calendar thisCalendar, Calendar thatCalendar) {
		thisCalendar.clear(Calendar.MILLISECOND);
		thatCalendar.clear(Calendar.MILLISECOND);
		
		return thisCalendar.equals(thatCalendar);
	}
	
	// End of segment: C:\Users\Ruyi\Desktop\collate\source\application\DateParser.java





	/**
	 * origin: C:\Users\Ruyi\Desktop\collate\source\application\Execution.java
	 */

	// -----------------------------------------------------------------------------------------------
	// Public methods
	// -----------------------------------------------------------------------------------------------
	public static String executeUserInput(String userInput) {
		String systemMsg = "";
		Command commandType = InputParser.getActionFromString(userInput);
		systemMsg = executeCommand(userInput, commandType);
		
		return systemMsg;
	}
	
	public static String executeUndo() {
		String systemMsg = null;
		
		boolean canUndo = !(Main.undos.isEmpty());
		if (canUndo) {
			Undo undo = Main.undos.pop();
			systemMsg = undo.undoAction();
		} else {
			systemMsg = Constant.MSG_NO_UNDO;
		}
		
		return systemMsg;
	}
	
	public static String executeRedo() {
		String systemMsg = null;
		
		boolean canRedo = !(Main.redos.isEmpty());
		if (canRedo) {
			Undo redo = Main.redos.pop();
			systemMsg = redo.redoAction();
		} else {
			systemMsg = Constant.MSG_NO_REDO;
		}
		
		return systemMsg;
	}
	
	/*
	 * Timer task to clear system message in header
	 */
	public static void executeSystemMsgTimerTask() {
		ExecutionTimer.SystemMsgTimerTask systemMsgTimerTask = 
				new ExecutionTimer.SystemMsgTimerTask();
		
		Timer timer = systemMsgTimerTask.getTimer();
		timer.schedule(systemMsgTimerTask, Constant.TIMER_SYSTEM_MSG_DURATION);
	}
	
	/*
	 * Timer task to check for overdue items and updates
	 * the status of those items
	 */
	public static void executeStatusCheckTimerTask() {
		ExecutionTimer.StatusCheckTimerTask statusCheckTimerTask = 
				new ExecutionTimer.StatusCheckTimerTask();
		
		Timer timer = statusCheckTimerTask.getTimer();
		timer.scheduleAtFixedRate(statusCheckTimerTask, 0, 
								  Constant.TIMER_UPDATE_STATUS_DURATION);
	}
	
	// End of segment: C:\Users\Ruyi\Desktop\collate\source\application\Execution.java





	/**
	 * origin: C:\Users\Ruyi\Desktop\collate\source\application\Execution.java
	 */

	public static void executeUpdateStatus() {
		Main.list.checkAndUpdateStatus();
		mainController.loadListsInTabs();
	}
	
	public static void executeClearSystemMsg() {
		headerController.lblSysMsg.setText(Constant.EMPTY_STRING);	
    	headerController.imgSysMsg.setImage(null);
	}
	
	// End of segment: C:\Users\Ruyi\Desktop\collate\source\application\Execution.java





	/**
	 * origin: C:\Users\Ruyi\Desktop\collate\source\application\ExecutionTimer.java
	 */

	public static class StatusCheckTimerTask extends TimerTask {
		private Timer _timer;
		
		public StatusCheckTimerTask() {
			_timer = new Timer();
		}
		
		public Timer getTimer() {
			return _timer;
		}
		 	
	    public void run() {
			Platform.runLater(new Runnable() {
			    @Override
			    public void run() {
	    			Execution.executeUpdateStatus();    	
			    }
			});
	    }
	}
	
	public static class SystemMsgTimerTask extends TimerTask {	
		private Timer _timer;
		
		public SystemMsgTimerTask() {
			_timer = new Timer();
		}
		
		public Timer getTimer() {
			return _timer;
		}
		 	
	    public void run() {
			Platform.runLater(new Runnable() {
			    @Override
			    public void run() {
			    	Execution.executeClearSystemMsg();
			    }
			});
			
			_timer.cancel();
	    }
	}
	
	// End of segment: C:\Users\Ruyi\Desktop\collate\source\application\ExecutionTimer.java





	/**
	 * origin: C:\Users\Ruyi\Desktop\collate\source\application\Frequency.java
	 */

package application;
public enum Frequency {
	NIL(null),
	DAILY(Command.RECURRING_DAILY),
	WEEKLY(Command.RECURRING_WEEKLY),
	MONTHLY(Command.RECURRING_MONTHLY),
	YEARLY(Command.RECURRING_YEARLY);
	
	private final Command _COMMAND;

	// -----------------------------------------------------------------------------------------------
	// Constructor
	// -----------------------------------------------------------------------------------------------			
	private Frequency(Command command) {
		_COMMAND = command;
	}
	
	// -----------------------------------------------------------------------------------------------
	// Get methods
	// -----------------------------------------------------------------------------------------------
	public Command getCommand() {
		return _COMMAND;
	}

	// -----------------------------------------------------------------------------------------------
	// Public methods
	// -----------------------------------------------------------------------------------------------		
	public static Frequency getFrequency(Command recurringCommand) {
		boolean hasFound = false;
		Frequency matchedFrequency = null;
		
		for (Frequency frequency : Frequency.values()) {
			Command frequencyCommand = frequency.getCommand();
			if (frequencyCommand == null) {
				continue;
			}
			
			hasFound = (frequencyCommand.equals(recurringCommand));
			if (hasFound) {
				matchedFrequency = frequency;
				break;
			}
		}
		
		return matchedFrequency;
	}
	
	public static boolean isWeekly(String commandLine) {		
		String lowerCase = commandLine.toLowerCase() + " ";
		String basicCmd = Command.RECURRING_WEEKLY.getBasicCommand() + " ";
		String advancedCmd = Command.RECURRING_WEEKLY.getAdvancedCommand() + " ";
		
		return (lowerCase.contains(basicCmd) ||
				lowerCase.contains(advancedCmd));
	}
	
	public static boolean isMonthly(String commandLine) {
		String lowerCase = commandLine.toLowerCase() + " ";
		String basicCmd = Command.RECURRING_MONTHLY.getBasicCommand() + " ";
		String advancedCmd = Command.RECURRING_MONTHLY.getAdvancedCommand() + " ";
		
		return (lowerCase.contains(basicCmd) ||
				lowerCase.contains(advancedCmd));
	}
	
	public static boolean isYearly(String commandLine) {
		String lowerCase = commandLine.toLowerCase() + " ";
		String basicCmd = Command.RECURRING_YEARLY.getBasicCommand() + " ";
		String advancedCmd = Command.RECURRING_YEARLY.getAdvancedCommand() + " ";
		
		return (lowerCase.contains(basicCmd) ||
				lowerCase.contains(advancedCmd));
	}
	
	public static boolean isDaily(String commandLine) {
		String lowerCase = commandLine.toLowerCase() + " ";
		String basicCmd = Command.RECURRING_DAILY.getBasicCommand() + " ";
		String advancedCmd = Command.RECURRING_DAILY.getAdvancedCommand() + " ";
		
		return (lowerCase.contains(basicCmd) ||
				lowerCase.contains(advancedCmd));
	}
	
}

	// End of segment: C:\Users\Ruyi\Desktop\collate\source\application\Frequency.java





	/**
	 * origin: C:\Users\Ruyi\Desktop\collate\source\application\InputParser.java
	 */

package application;

import java.util.ArrayList;
import java.util.List;
import java.util.Date;
import java.util.logging.Level;

import javafx.util.Pair;

import com.joestelmach.natty.DateGroup;
import com.joestelmach.natty.Parser;

public class InputParser {
	private static InputParser _inputParser;
	private Parser _parser;
	
	// -----------------------------------------------------------------------------------------------
	// Constructor
	// -----------------------------------------------------------------------------------------------		
	private InputParser() {
		_parser = new Parser();
	}
	
	// -----------------------------------------------------------------------------------------------
	// Get methods
	// -----------------------------------------------------------------------------------------------	
	public static InputParser getInstance() {
		if (_inputParser == null) {
			_inputParser = new InputParser();
		}
		
		return _inputParser;
	}
	
	// -----------------------------------------------------------------------------------------------
	// Public methods
	// -----------------------------------------------------------------------------------------------	
	public static Command getActionFromString(String userInput) {
		return Command.verifyCrudCommands(userInput);
	}
	
	public static TaskType getTaskTypeFromString(String userInput) {
		return TaskType.verifyTaskType(userInput.toLowerCase());
	}
	
	public Date getDateFromString(String dateString) {
		List<Date> dates = getDatesFromString(dateString);
		
		if (dates != null) {
			return dates.get(0);
		} else {
			return null;
		}
	}
	
	public List<Date> getDatesFromString(String userInput) {
		String checkString = userInput.toLowerCase() + " ";
		String basicCmd = Command.TO.getBasicCommand();
		String advancedCmd = Command.TO.getAdvancedCommand();
		int endIndex = checkString.length();
		int startIndex = -1;
		
		List<DateGroup> groups = _parser.parse(checkString);
		
		if (groups.isEmpty()) {
			return null;
		}			
		else {
			List<Date> dates = groups.get(0).getDates();
			
			// check for /to command
			if (checkString.contains(basicCmd)) {
				startIndex = checkString.indexOf(basicCmd) + 
							 basicCmd.length();				
			} else if (checkString.contains(advancedCmd)) {
				startIndex = checkString.indexOf(advancedCmd) + 
							 basicCmd.length();		
			}
			
			// extract /to date
			if (startIndex != -1) {
				checkString = checkString.substring(startIndex, endIndex);
				List<Date> toDates = getDatesFromString(checkString);
				if (toDates != null) {
					dates.add(toDates.get(0));
				}
			} 
			
			return dates;
		}
	}
	
	public Date getSearchDateFromString(String userInput) {
		String checkString = userInput.toLowerCase() + " ";
		
		List<DateGroup> groups = _parser.parse(checkString);
		
		if (groups.isEmpty()) {
			return null;
		}			
		else {
			List<Date> dates = groups.get(0).getDates();
			
			return dates.get(0);
		}		
	}
	
	public static String getCategoryFromString(String userInput) {
		boolean isCategorised = Command.hasCategoryCommand(userInput);
		
		if (isCategorised) {
			String basicCmd = Command.CATEGORY.getBasicCommand();
			
			int commandIndex = userInput.indexOf(basicCmd);
			String concatString = userInput.substring(commandIndex + 
								  basicCmd.length(), 
								  userInput.length());
			
			boolean noWhiteSpace = (concatString.indexOf(" ") == -1);
			if (noWhiteSpace) {
				return concatString;
			} else {
				return concatString.substring(0, concatString.indexOf(" "));				
			}
		}
		
		return Constant.CATEGORY_UNCATEGORISED;
	}
	
	public static String getTargetIdFromString(String userInput) {
		int endIndex = userInput.length();
		String targetId = getTargetId(userInput, endIndex);

		return targetId;
	}
	
	public static String[] getTargetIdsFromString(String userInput) {
		int endIndex = userInput.length();
		String targetIdsString = getTargetId(userInput, endIndex);
		String[] targetIds = targetIdsString.split(Constant.REGEX_SPACE);
		
		return targetIds;
	}
	
	public static String getTargetIdFromUpdateString(String userInput) {
		String targetId = null;
		
		int endIndex = userInput.indexOf(Constant.DELIMITER_UPDATE + " ");
		
		if (endIndex == -1) {
			int minLength = 2;
			int idIndex = 1;
			
			String[] words = userInput.split(" ");
			
			if (words.length == minLength) {
				targetId = words[idIndex];
			}
		} else {
			targetId = getTargetId(userInput, endIndex);
		}
						
		return targetId;
	}
	
	public static Priority getPriorityFromString(String userInput) {
		if (Priority.isHigh(userInput)) {
			return Priority.HIGH;
		} else if (Priority.isMedium(userInput)) {
			return Priority.MEDIUM;
		} else if (Priority.isLow(userInput)) {
			return Priority.LOW;
		} else {
			return Priority.NEUTRAL;
		}
	}
	
	public static String getDateString(Date date) {
		String dateString = Constant.XML_TEXT_NIL;
		
		if (date != null) {
			dateString = date.toString();
		}
		
		return dateString;
	}
	
	public static Date getUntilDateFromString(String userInput) {
		Date untilDate = null;
		String lowerCase = userInput.toLowerCase() + " ";
		
		int beginIndex = Command.RECURRING_UNTIL.getIndexOfCommand(userInput);
		int endIndex = userInput.length();
		
		boolean hasUntil = (beginIndex != -1);
		if (hasUntil) {
			lowerCase = lowerCase.substring(beginIndex, endIndex);
			untilDate = Main.inputParser.getDateFromString(lowerCase);
		}
		
		return untilDate;
	}

	public static String removeActionFromString(String userInput, String id) {	
		String toDoString = userInput;		
		
		toDoString = InputParser.removeAddFromString(userInput); 		
		toDoString = InputParser.removeUpdateFromString(toDoString, id);
		
		return toDoString;
	}
	
	public static String extractDescriptionFromString(String userInput, 
													  TaskType taskType, 
													  String id) {
		String extractedString = InputParser.removeActionFromString(userInput, id);
		
		int beginIndex = 0;
		int endIndex = extractedString.length();
		
		String toBeRemoved = null;
		Command typeCommand = taskType.getDateCommand();		
		
		if (typeCommand != null) {
			beginIndex = typeCommand.getIndexOfCommand(extractedString);
			
			boolean toExtract = (beginIndex != -1);
			if (toExtract) {
				toBeRemoved = extractedString.substring(beginIndex, endIndex);
				extractedString = extractedString.replace(toBeRemoved, "");
			}			
		}		
		
		return extractedString;
	}
	
	public static String removeRecurrenceFromString(String toDoString, 
			 									   boolean isRecurring, Frequency repeat) {
		if (isRecurring) {
			Command recurringCommand = repeat.getCommand();
			int endIndex = recurringCommand.getIndexOfCommand(toDoString);

			toDoString = extractFromString(toDoString, endIndex);
		}
		return toDoString;
	}
	
	public static String removePriorityFromString(String toDoString, Priority priority) {
		boolean isPrioritised = (!priority.equals(Priority.NEUTRAL));
		
		if (isPrioritised) {
			Command priorityCommand = priority.getCommand();
			int endIndex = priorityCommand.getIndexOfCommand(toDoString);
			
			toDoString = extractFromString(toDoString, endIndex);
		}
		return toDoString;
	}
	
	public static String removeCategoryFromString(String toDoString, String category) {
		boolean isCategorised = (!category.equals(Constant.CATEGORY_UNCATEGORISED));
		String lowerCase = toDoString.toLowerCase() + " ";
		
		if (isCategorised) {
			String categoryCommand = Command.CATEGORY.getBasicCommand() + 
									 category.toLowerCase();
			int endIndex = lowerCase.indexOf(categoryCommand);			
			
			toDoString = toDoString.substring(0, endIndex);
		}
		return toDoString;
	}
	
	/*
	 * returns a list of search attribute pairs consisting
	 * of the attribute to search by and the key to match with
	 */
	public static ArrayList<Pair<SearchAttribute, String>> 
		getSearchAttributePairFromString(String userInput) {
		
		ArrayList<Pair<SearchAttribute, String>> attributePairs = 
				new ArrayList<Pair<SearchAttribute, String>>();
		String searchKey = null;

		ArrayList<SearchAttribute> attributes = SearchAttribute
				.getSearchAttributes(userInput);

		for (SearchAttribute attribute : attributes) {
			searchKey = InputParser.
						getSearchKeyFromString(userInput, attribute);

			if (searchKey != null) {
				attributePairs.
				add(new Pair<SearchAttribute, String>(attribute, searchKey));
			}
		}

		return attributePairs;
	}
	
	public static String verifyAndCorrectSearchString(String userInput) {
		userInput = InputParser.removeLineBreaks(userInput);
		userInput = userInput + " ";
		
		int expectedPosition = userInput.length() - 2;
		int actualPosition = userInput.lastIndexOf(Constant.DELIMITER_SEARCH);
		
		if (actualPosition != expectedPosition) {
			userInput += Constant.DELIMITER_SEARCH;
		}
		
		return userInput;
	}
	
	public static String removeLineBreaks(String userInput) {
		userInput = userInput.trim().
					replaceAll(Constant.REGEX_LINE_BREAK, "");
		
		return userInput;
	}
	
	/*
	 * Get the task id of the task which carries the
	 * recurring child task item
	 */
	public static String getTaskIdFromRecurringId(String targetId) {
		int prefixIndex = targetId.
		   		  indexOf(Constant.PREFIX_RECURRING_ID);
		
		String taskId = targetId.substring(0, prefixIndex);
		
		return taskId;
	}
	
	public static String getChildIdFromRecurringId(String targetId) {
		int prefixIndex = targetId.
		   		  indexOf(Constant.PREFIX_RECURRING_ID);
		int startIndex = prefixIndex + 1;
		int endIndex = targetId.length();
		
		String recurringTaskId = targetId.substring(startIndex, endIndex);	
		
		return recurringTaskId;
	}
	
	// -----------------------------------------------------------------------------------------------
	// Private methods
	// -----------------------------------------------------------------------------------------------	
	private static String extractFromString(String toDoString, int endIndex) {
		boolean canSubstring = (endIndex != -1);
		if (canSubstring) {
			toDoString = toDoString.substring(0, endIndex);
		}
		
		return toDoString;
	}
	
	private static String getTargetId(String userInput, int endIndex) {
		String targetId = null;
		
		try {
			Command command = getActionFromString(userInput);
			String basicCommand = command.getBasicCommand() + " ";
			String advancedCommand = command.getAdvancedCommand() + " ";
			int beginIndex = -1;
			
			if (userInput.contains(basicCommand)) {
				beginIndex = basicCommand.length();
				targetId = userInput.substring(beginIndex, endIndex);
				
			} else if (userInput.contains(advancedCommand)) {
				beginIndex = advancedCommand.length();
				targetId = userInput.substring(beginIndex, endIndex);
			}
		} catch (StringIndexOutOfBoundsException exception) {
			Main.LOGGER.logp(Level.WARNING, 
							 InputParser.class.getName(), 
							 "getTargetId", 
							 exception.getMessage());
			return targetId;
		}
				
		return targetId;
	}
	
	private static String removeUpdateFromString(String userInput, String id) {
		if (id == null) {
			return userInput;
		}
		
		String toDoString = userInput;	
		String lowerCase = userInput.toLowerCase() + " ";	
		String updateBasicCmd = Command.UPDATE.getBasicCommand();
		String updateAdvancedCmd = Command.UPDATE.getAdvancedCommand();
		
		String updateBasicString = updateBasicCmd + " " +
								   id.toLowerCase() + 
								   Constant.DELIMITER_UPDATE;
		String updateAdvancedString = updateAdvancedCmd + " " +
								      id.toLowerCase() + 
								      Constant.DELIMITER_UPDATE;
		
		if ((lowerCase.contains(updateBasicString) &&
			 lowerCase.indexOf(updateBasicString) == 0) ||
			(lowerCase.contains(updateAdvancedString) &&
			 lowerCase.indexOf(updateAdvancedString) == 0)) {
			
			int delimeterIndex = userInput.indexOf(Constant.DELIMITER_UPDATE + " ");			
			int startIndex = delimeterIndex + 1;
			int endIndex = userInput.length();
					
			if (startIndex < endIndex) {
				toDoString = userInput.substring(startIndex, endIndex);
			} else {
				toDoString = Constant.EMPTY_DESCRIPTION;
			}			
		}
		
		return toDoString;
	}

	private static String removeAddFromString(String userInput) {
		String lowerCase = userInput.toLowerCase() + " ";
		String addBasicCmd = Command.ADD.getBasicCommand() + " ";
		String addAdvancedCmd = Command.ADD.getAdvancedCommand() + " ";
		
		int lengthOfBasicAddCommand = addBasicCmd.length();
		int lengthOfAdvancedAddCommand = addAdvancedCmd.length();
		
		String toDoString = userInput;
							
		if (lowerCase.contains(addBasicCmd) &&
			lowerCase.indexOf(addBasicCmd) == 0){
			
			if ((lengthOfBasicAddCommand >= userInput.length() ||
				 lengthOfAdvancedAddCommand >= userInput.length())) { // empty description
					return "";
			} 
			
			toDoString = userInput.substring(lengthOfBasicAddCommand, 
						 					 userInput.length()).trim();
			
		} else if (lowerCase.contains(addAdvancedCmd) &&
				   lowerCase.indexOf(addAdvancedCmd) == 0) {
			
			if ((lengthOfBasicAddCommand >= userInput.length() ||
					 lengthOfAdvancedAddCommand >= userInput.length())) { // empty description
						return "";
			}
			
			toDoString = userInput.substring(lengthOfAdvancedAddCommand, 
						 					  userInput.length()).trim();
		}
		
		return toDoString;
	}
			
	private static String getSearchKeyFromString(String userInput, 
										   SearchAttribute attribute) {
		String searchKey = null;
		String lowerCase = userInput.toLowerCase();
		String command = attribute.getCommand();
		
		if (lowerCase.contains(command)) {		
			int startIndex = lowerCase.indexOf(command) + command.length();
			int endIndex = lowerCase.length();
			
			String detailString = lowerCase.substring(startIndex, endIndex);
			endIndex = detailString.indexOf(Constant.DELIMITER_SEARCH);
			
			searchKey = detailString.substring(0, endIndex);
		}
		
		return searchKey;
	}
}

	// End of segment: C:\Users\Ruyi\Desktop\collate\source\application\InputParser.java





	/**
	 * origin: C:\Users\Ruyi\Desktop\collate\source\application\Priority.java
	 */

package application;
public enum Priority {
	NEUTRAL(null),
	LOW(Command.PRIORITY_LOW),
	MEDIUM(Command.PRIORITY_MEDIUM),
	HIGH(Command.PRIORITY_HIGH);
	
	private final Command _COMMAND;

	// -----------------------------------------------------------------------------------------------
	// Constructor
	// -----------------------------------------------------------------------------------------------		
	private Priority(Command command) {
		_COMMAND = command;
	}
	
	// -----------------------------------------------------------------------------------------------
	// Get methods
	// -----------------------------------------------------------------------------------------------
	public Command getCommand() {
		return _COMMAND;
	}
	
	// -----------------------------------------------------------------------------------------------
	// Public methods
	// -----------------------------------------------------------------------------------------------		
	public static boolean isLow(String commandLine) {
		String lowerCase = commandLine.toLowerCase() + " ";
		String basicCmd = Command.PRIORITY_LOW.getBasicCommand() + " ";
		String advancedCmd = Command.PRIORITY_LOW.getAdvancedCommand() + " ";
		
		return (lowerCase.contains(basicCmd) ||
				lowerCase.contains(advancedCmd));
	}
	
	public static boolean isMedium(String commandLine) {
		String lowerCase = commandLine.toLowerCase() + " ";
		String basicCmd = Command.PRIORITY_MEDIUM.getBasicCommand() + " ";
		String advancedCmd = Command.PRIORITY_MEDIUM.getAdvancedCommand() + " ";
		
		return (lowerCase.contains(basicCmd) ||
				lowerCase.contains(advancedCmd));
	}
	
	public static boolean isHigh(String commandLine) {
		String lowerCase = commandLine.toLowerCase() + " ";
		String basicCmd = Command.PRIORITY_HIGH.getBasicCommand() + " ";
		String advancedCmd = Command.PRIORITY_HIGH.getAdvancedCommand() + " ";
		
		return (lowerCase.contains(basicCmd) ||
				lowerCase.contains(advancedCmd));
	}
}

	// End of segment: C:\Users\Ruyi\Desktop\collate\source\application\Priority.java





	/**
	 * origin: C:\Users\Ruyi\Desktop\collate\source\application\RecurringTask.java
	 */

package application;

import java.util.Calendar;
import java.util.Date;

public class RecurringTask implements Cloneable {
	private String _recurringTaskId;
	private TaskStatus _status;
	private Date _recurDate;
	
	// -----------------------------------------------------------------------------------------------
	// Constructors
	// -----------------------------------------------------------------------------------------------	
	public RecurringTask() {
		/*
		 * attributes to be filled up by XmlManager
		 */
	}
	
	public RecurringTask(String recurringTaskId, Date recurDate) {
		_recurringTaskId = recurringTaskId;
		_status = TaskStatus.getTaskStatus(recurDate);
		_recurDate = recurDate;
	}
	
	public RecurringTask(String recurringTaskId, Calendar recurDateCalendar) {
		_recurringTaskId = recurringTaskId;
		
		Date recurDate = recurDateCalendar.getTime();
		_status = TaskStatus.getTaskStatus(recurDate);
		
		_recurDate = recurDate;
	}
	
	// -----------------------------------------------------------------------------------------------
	// Get methods
	// -----------------------------------------------------------------------------------------------
	public String getRecurringTaskId() {
		return _recurringTaskId;
	}

	public TaskStatus getStatus() {
		return _status;
	}

	public Date getRecurDate() {
		return _recurDate;
	}
	
	// -----------------------------------------------------------------------------------------------
	// Set methods
	// -----------------------------------------------------------------------------------------------
	public void setRecurringTaskId(String recurringTaskId) {
		_recurringTaskId = recurringTaskId;
	}

	public void setStatus(TaskStatus status) {
		_status = status;
	}

	public void setRecurDate(Date recurDate) {
		_recurDate = recurDate;
	}

	// -----------------------------------------------------------------------------------------------
	// Public methods
	// -----------------------------------------------------------------------------------------------		
	public static boolean isValidRecurringTaskType(TaskType taskType) {
		return (taskType.equals(TaskType.DATED) ||
				taskType.equals(TaskType.EVENT));
	}
		
	@Override
	public RecurringTask clone() {
		RecurringTask clone = null;
		
		try {
			clone = (RecurringTask) super.clone();
		} catch(CloneNotSupportedException exception){
            throw new RuntimeException(exception); 
        }
		
		 return clone;
	}
}

	// End of segment: C:\Users\Ruyi\Desktop\collate\source\application\RecurringTask.java





	/**
	 * origin: C:\Users\Ruyi\Desktop\collate\source\application\SearchAttribute.java
	 */

package application;

import java.util.ArrayList;

public enum SearchAttribute {
	ID("id="),
	DESCRIPTION("des="),
	DATE("date="),
	CATEGORY("cat="),
	PRIORITY("pri=");
	
	private final String _COMMAND;
	
	// -----------------------------------------------------------------------------------------------
	// Constructor
	// -----------------------------------------------------------------------------------------------	
	private SearchAttribute(String command) {
		_COMMAND = command;
	}
	
	// -----------------------------------------------------------------------------------------------
	// Get methods
	// -----------------------------------------------------------------------------------------------
	public String getCommand() {
		return _COMMAND;
	}

	// -----------------------------------------------------------------------------------------------
	// Public methods
	// -----------------------------------------------------------------------------------------------		
	public static ArrayList<SearchAttribute> getSearchAttributes(String commandLine) {
		String lowerCase = commandLine.toLowerCase();
		ArrayList<SearchAttribute> attributes = new ArrayList<SearchAttribute>();
		
		for (SearchAttribute attribute : SearchAttribute.values()) {
			if (lowerCase.contains(attribute.getCommand())) {
				attributes.add(attribute);
			}
		}
		
		return attributes;
	}
}

	// End of segment: C:\Users\Ruyi\Desktop\collate\source\application\SearchAttribute.java





	/**
	 * origin: C:\Users\Ruyi\Desktop\collate\source\application\Storage.java
	 */

	// -----------------------------------------------------------------------------------------------
	// Constructor
	// -----------------------------------------------------------------------------------------------		
	private Storage() {		
		initTransformer();			
		_xPath = XmlManager.getNewXPath();
		_documentBuilder = XmlManager.getNewDocBuilder();
	}
	
	// -----------------------------------------------------------------------------------------------
	// Get methods
	// -----------------------------------------------------------------------------------------------
	public static Storage getInstance() {
		if (_storage == null) {
			_storage = new Storage();
		}
		
		return _storage;
	}
	
	// -----------------------------------------------------------------------------------------------
	// Public methods
	// -----------------------------------------------------------------------------------------------
	// ---------------------------------------------------------
	// Read-related methods
	// ---------------------------------------------------------
	public int readNextId() {
		int nextId = 0;
		Document fileDoc = getFileDocument();	
		
		try {
			XPathExpression expression = 
					_xPath.compile(Constant.XML_XPATH_NEXT_ID);
			
			Double value = (Double)expression.
						   evaluate(fileDoc, XPathConstants.NUMBER);
			
			nextId = value.intValue();
		} catch (XPathExpressionException exception) {
			Main.LOGGER.logp(Level.SEVERE, 
							 Storage.class.getName(), 
							 "readNextId", 
							 exception.getMessage());
		}
		
		return nextId;
	}
	
	public String readSavePath() {
		String savePath = null;
		Document settingDoc = getSettingDocument();		
		
		try {
			XPathExpression expression = 
					_xPath.compile(Constant.XML_XPATH_SETTING_SAVE);
			
			savePath = (String) expression.
					   evaluate(settingDoc, XPathConstants.STRING);
			
			if (savePath.equals(Constant.PATH_DEFAULT)) {
				savePath = Main.getFolderPath() + Constant.PATH_DEFAULT;

			}
		} catch (XPathExpressionException exception) {
			Main.LOGGER.logp(Level.SEVERE, 
							 Storage.class.getName(), 
							 "readSavePath", 
							 exception.getMessage());
		}
		
		return savePath;
	}
	
	/*
	 * Used in unit testing
	 */
	public void updateFilePathInSetting(String filePath) {
		Document doc = getSettingDocument();

		Node save = doc.getElementsByTagName(Constant.TAG_SETTING_SAVE).item(0);
		save.setTextContent(filePath);
		
		writeFile(doc, Constant.PATH_SETTING);
	}
	
	// ---------------------------------------------------------
	// Write-related methods
	// ---------------------------------------------------------
	public String writeFile(Document document) {
		return writeFile(document, Main.list.getListFilePath());
	}
	
	public String writeFile(Document document, String savePath) {
		try {
			DOMSource domSource = new DOMSource(document);
			StreamResult streamResult = null;
			
			if (savePath.equals(Constant.PATH_SETTING)) {
				savePath = Main.getFolderPath() + savePath;		
			} 
			
			streamResult = new StreamResult(new File(savePath));
			_transformer.transform(domSource, streamResult);
		} catch (TransformerException exception) {
			Main.LOGGER.logp(Level.SEVERE, 
							 Storage.class.getName(), 
							 "writeFile", 
							 exception.getMessage());
		}
		
		return Constant.MSG_SAVE_SUCCESS;
	}


	public ArrayList<Task> loadTasksXmlToArrayList() {
		Document document = getFileDocument();
		ArrayList<Task> tasks = new ArrayList<Task>();
		
		Element root = document.getDocumentElement();
		NodeList taskNodes = root.
				getElementsByTagName(Constant.TAG_TASK);
		
		Node taskNode = null;
		for (int i = 0; i < taskNodes.getLength(); i++) {
			taskNode = taskNodes.item(i);
			
			Task task = XmlManager.transformNodeToTask(taskNode);
			tasks.add(task);
		}
		
		return tasks;
	}

	public ArrayList<String> loadCategoriesXmlToArrayList() {
		Document document = getFileDocument();
		ArrayList<String> categories = new ArrayList<String>();
		
		Element root = document.getDocumentElement();
		NodeList categoryNodes = root.getElementsByTagName(Constant.TAG_CATEGORY);
		
		Node categoryNode = null;
		String categoryString = null;
		for (int i = 0; i < categoryNodes.getLength(); i++) {
			categoryNode = categoryNodes.item(i);
			categoryString = categoryNode.getTextContent();
			
			categories.add(categoryString);
		}
		
		return categories;
	}
	
	public String writeListToFile(ArrayList<Task> tasks) {
		removeAllTaskNodesFromFile();
		Document document = getFileDocument();

		Element root = document.getDocumentElement();
		Node tasksNode = (Node) root.
				getElementsByTagName(Constant.TAG_TASKS).item(0);
		
		Node taskNode = null;
		Task task = null;
		for (int i = 0; i < tasks.size(); i++) {
			task = tasks.get(i);
			
			taskNode = XmlManager.transformTaskToXml(document, task);
			tasksNode.appendChild(taskNode);
		}
		
		cleanAndWriteFile(document);
		
		return Constant.MSG_ADD_SUCCESS;
	}
	
	public boolean hasWrittenCategoryToFile(String category) {
		Document document = getFileDocument();
		boolean hasWritten = false;
		
		Element root = document.getDocumentElement();
		Element categoriesNode = (Element) root.
				getElementsByTagName(Constant.TAG_CATEGORIES).item(0);
		
		XmlManager.createAndAppendChildElement(document, categoriesNode, 
				   Constant.TAG_CATEGORY, category);	

		writeFile(document);
		hasWritten = true;
		
		return hasWritten;
	}
	
	public void writeNextIdInFile(int nextId) {
		Document document = getFileDocument();
		
		Element root = document.getDocumentElement();
		Element nextIdNode = (Element) root.
				getElementsByTagName(Constant.TAG_NEXT_ID).item(0);
		nextIdNode.setTextContent(String.valueOf(nextId));
		
		writeFile(document);
	}
	
	// ---------------------------------------------------------
	// Others
	// ---------------------------------------------------------
	public Document getFileDocument() {
		try {
			return _documentBuilder.parse(Main.storage.readSavePath()); 			
		} catch (SAXException | IOException exception) {
			Main.LOGGER.logp(Level.SEVERE, 
							 Storage.class.getName(), 
							 "getFileDocument", 
							 exception.getMessage());
		}			
		return null;
	}
	
	public Document getSettingDocument() {
		try {						
			return _documentBuilder.parse(Main.getFolderPath() + 
										  Constant.PATH_SETTING); 			
		} catch (SAXException | IOException exception) {
			Main.LOGGER.logp(Level.SEVERE, 
							 Storage.class.getName(), 
							 "getSettingDocument", 
							 exception.getMessage());
		}			
		return null;
	}

	public String moveFile(String path) { 
		String systemMsg;
		
		String pathInSetting = readSavePath();
		Path oldPath = Paths.get(pathInSetting);		
		Path newPath = Paths.get(path); 
		
		try {
			Files.move(oldPath, newPath.resolve(oldPath.getFileName()), 
					   StandardCopyOption.REPLACE_EXISTING);
		} catch (IOException exception) {
			exception.printStackTrace();
		}
		
		systemMsg = updateDirPathInSetting(path); 
		
		Main.list = new ToDoList();
		
		return systemMsg;
	}
	
	// End of segment: C:\Users\Ruyi\Desktop\collate\source\application\Storage.java





	/**
	 * origin: C:\Users\Ruyi\Desktop\collate\source\application\Storage.java
	 */

	private void cleanAndWriteFile(Document document) {
		try {
			NodeList nodes = (NodeList) _xPath.
							evaluate(Constant.XML_WHITESPACE_NODE_XPATH, 
							document, XPathConstants.NODESET);
			
			for (int i = 0; i < nodes.getLength(); i++) {
			    Node node = nodes.item(i);
			    node.getParentNode().removeChild(node);
			}
			
			writeFile(document);
		} catch (XPathExpressionException exception) {
			Main.LOGGER.logp(Level.SEVERE, 
							 Storage.class.getName(), 
							 "cleanAndWriteFile", 
							 exception.getMessage());
		}
	}
	
	private void removeAllTaskNodesFromFile() {
		Document document = getFileDocument();
		Element root = document.getDocumentElement();
		
		try {
			XPathExpression expression = _xPath.compile("/" + Constant.TAG_FILE + 
												"/" + Constant.TAG_TASKS);
			
			Element tasksNode = (Element) expression.
								evaluate(document, XPathConstants.NODE);
			
			tasksNode.getParentNode().removeChild(tasksNode);
			XmlManager.createAndAppendWrapper(document, root, 
					   						  String.valueOf(Constant.TAG_TASKS));
			
			cleanAndWriteFile(document);
		} catch (Exception exception) {
			Main.LOGGER.logp(Level.SEVERE, 
							 Storage.class.getName(), 
							 "removeAllTaskNodesFromFile", 
							 exception.getMessage());
		}
	}
		
	private void initTransformer() {
		try {
			TransformerFactory transformerFactory = 
					TransformerFactory.newInstance();
			
			_transformer = transformerFactory.newTransformer();
			_transformer.setOutputProperty(OutputKeys.INDENT, 
					   					   Constant.XML_OUTPUT_INDENT);
			_transformer.setOutputProperty(Constant.XML_OUTPUT_INDENT_PROPERTY, 
										   Constant.XML_OUTPUT_INDENT_AMOUNT);
		} catch (TransformerConfigurationException exception) {
			Main.LOGGER.logp(Level.SEVERE, 
							 Storage.class.getName(), 
							 "initTransformer", 
							 exception.getMessage());
		}
	}
	
	private boolean isEmptyCategory(String category) {
		boolean isEmpty = true;
		
		ArrayList<Task> taskList = Main.list.getTasks();
		
		for(int i = 0; i < taskList.size(); i++) {
			if(taskList.get(i).getCategory().equalsIgnoreCase(category)) {
				isEmpty = false;
				break;
			}
		}
		
		return isEmpty;
	}
}
	// End of segment: C:\Users\Ruyi\Desktop\collate\source\application\Storage.java





	/**
	 * origin: C:\Users\Ruyi\Desktop\collate\source\application\Task.java
	 */

	// -----------------------------------------------------------------------------------------------
	// Constructors
	// -----------------------------------------------------------------------------------------------		
	public Task() {		
		// Attributes are to be occupied by calling set
	}
	
	public Task(String userInput) {
		this(userInput, null);
	}
	
	public Task(String userInput, String id) {	
		this(userInput, id, null);
	}
	
	public Task (String userInput, String id, Task originalTask) {
		_isValid = false;
		_taskType = InputParser.getTaskTypeFromString(userInput);	
		
		if (id == null) {
			_id = String.valueOf(Main.list.getNextId());	
		} else {
			_id = id;	
		}
		
		_originalText = InputParser.removeActionFromString(userInput, _id);
		
		boolean hasValidDateCount = Command.hasValidNumOfDateCommands(userInput);
		if (hasValidDateCount) {
			List<Date> dates = getDates(userInput);
			
			boolean isInvalidFormat = (_taskType.equals(TaskType.TIMED) && 
									   dates.size() < Constant.MAX_NUM_OF_DATES) ||
									  (!_taskType.equals(TaskType.FLOATING) && 
									   dates == null);
			
			if (isInvalidFormat) {
				Main.systemFeedback = Constant.MSG_INVALID_FORMAT;
			} else {
				setTaskContentAttributes(userInput, originalTask, dates);
			}
		} else {
			boolean isInvalidRecurring = 
					Command.verifyRecurringCommands(userInput) != null;
			
			if (isInvalidRecurring) {
				Main.systemFeedback = Constant.MSG_INVALID_RECURRING;
			} else {
				Main.systemFeedback = Constant.MSG_INVALID_FORMAT;
			}			
		}
	}
	
	// -----------------------------------------------------------------------------------------------
	// Get methods
	// -----------------------------------------------------------------------------------------------	
	public String getId() {
		return _id;
	}

	public TaskType getTaskType() {
		return _taskType;
	}
	
	public String getToDo() {
		return _toDo;
	}
	
	public String getOriginalText() {
		return _originalText;
	}

	public Date getOn() {
		return _on;
	}

	public Date getFrom() {
		return _from;
	}

	public Date getTo() {
		return _to;
	}

	public Date getBy() {
		return _by;
	}

	public String getCategory() {
		return _category;
	}
	
	public boolean getIsRecurring() {
		return _isRecurring;
	}

	public Frequency getRepeat() {
		return _repeat;
	}

	public Priority getPriority() {
		return _priority;
	}
	
	public boolean getIsValid() {
		return _isValid;
	}

	public int getRepeatDay() {
		return _repeatDay;
	}

	public Date getRepeatUntil() {
		return _repeatUntil;
	}

	public Date getEndDate() {
		return _endDate;
	}

	public TaskStatus getStatus() {
		return _status;
	}

	public ArrayList<RecurringTask> getRecurringTasks() {
		return _recurringTasks;
	}

	public Date getStartDate() {
		return _startDate;
	}
	
	// -----------------------------------------------------------------------------------------------
	// Set methods
	// -----------------------------------------------------------------------------------------------
	public void setId(String id) {
		_id = id;
	}
	
	public void setTaskType(TaskType _taskType) {
		this._taskType = _taskType;
	}

	public void setToDo(String toDo) {
		_toDo = toDo;
	}

	public void setOriginalText(String originalText) {
		_originalText = originalText;
	}

	public void setOn(Date on) {
		_on = on;
	}

	public void setFrom(Date from) {
		_from = from;
	}

	public void setTo(Date to) {
		_to = to;
	}

	public void setBy(Date by) {
		_by = by;
	}

	public void setCategory(String category) {
		_category = category;
	}

	public void setIsRecurring(boolean isRecurring) {
		_isRecurring = isRecurring;
	}

	public void setRepeat(Frequency repeat) {
		_repeat = repeat;
	}

	public void setPriority(Priority priority) {
		_priority = priority;
	}
	
	public void setIsValid(boolean isValid) {
		_isValid = isValid;
	}
	
	public void setRepeatDay(int repeatDay) {
		_repeatDay = repeatDay;
	}

	public void setRepeatUntil(Date repeatUntil) {
		_repeatUntil = repeatUntil;
	}
	
	public void setEndDate(Date endDate) {
		_endDate = endDate;
	}

	public void setStatus(TaskStatus status) {
		_status = status;
	}

	public void setRecurringTasks(ArrayList<RecurringTask> recurringTask) {
		_recurringTasks = recurringTask;
	}
	
	public void setStartDate(Date startDate) {
		_startDate = startDate;
	}
	
	// -----------------------------------------------------------------------------------------------
	// Public Methods
	// -----------------------------------------------------------------------------------------------
	@Override
	public Task clone() {
		Task clone = null;
		
		try {
			clone = (Task) super.clone();
		} catch(CloneNotSupportedException exception) {
			Main.LOGGER.logp(Level.WARNING, 
							 Task.class.getName(), 
							 "clone", 
							 exception.getMessage());
            throw new RuntimeException(exception); 
        }
		
		 return clone;
	}
	
	public Task deepCloneTask() {
		Task copy = this.clone();
		
		if (copy.getIsRecurring()) {
			copy.setRecurringTasks(copy.deepCloneArrayList());
		}
		
		return copy;
	}
		
	public ArrayList<RecurringTask> deepCloneArrayList() {
		ArrayList<RecurringTask> copies = new ArrayList<RecurringTask>();
		Iterator<RecurringTask> iterator = _recurringTasks.iterator();
		
		while(iterator.hasNext()) {
			copies.add(iterator.next().clone());
		}
		
		return copies;
	}
	
	// End of segment: C:\Users\Ruyi\Desktop\collate\source\application\Task.java





	/**
	 * origin: C:\Users\Ruyi\Desktop\collate\source\application\Task.java
	 */

	public void deleteRecurringTaskById(String recurringTaskId) {
		RecurringTask recurringTask = null;
		int index = 0;		
		boolean isFound = false;
		Iterator<RecurringTask> taskIterator = _recurringTasks.iterator();
		
		while (taskIterator.hasNext()) {
			recurringTask = taskIterator.next();
			
			isFound = (recurringTask.getRecurringTaskId().
					   equals(recurringTaskId));
			
			if (isFound) {
				/*
				 * Setting the status to Status.DELETED instead of deleting
				 * the task from the xml in order for the update function
				 * to work correctly when updating recurring tasks
				 */
				recurringTask.setStatus(TaskStatus.DELETED);
				break;
			}
			
			index++;
		}
	}
	
	/*
	 * return true when the start date of the calling task matches
	 * with the search key
	 */
	public boolean hasDateMatch(SearchAttribute attribute, String searchKey) {
		boolean hasMatched = false;
		Date dateKey = Main.inputParser.getSearchDateFromString(searchKey);
		
		if (dateKey == null || _startDate == null) {
			return false;
		} else if (DateParser.hasMatchedDateOnly(dateKey, _startDate)){
			hasMatched = true;
		}
				
		return hasMatched;
	}
	
	public boolean hasMatchedAllAttributes(ArrayList<Pair<SearchAttribute, String>> attributePairs) {
		boolean hasMatched = false;
		SearchAttribute attribute = null;
		String searchKey = null;
		String taskDetailString = null;
		int matched = 0;
		int expectedMatched = attributePairs.size();

		for (Pair<SearchAttribute, String> attributePair : attributePairs) {
			attribute = attributePair.getKey();
			searchKey = attributePair.getValue().trim();

			switch (attribute) {
			case ID:
				taskDetailString = _id.toLowerCase();
				break;
			case DESCRIPTION:
				taskDetailString = _toDo.toLowerCase();
				break;
			case CATEGORY:
				taskDetailString = _category.toLowerCase();
				break;
			case PRIORITY:
				taskDetailString = _priority.toString().toLowerCase();
				break;
			case DATE:
				if (hasDateMatch(attribute, searchKey)) {
					matched++;

				}
				continue;
			}

			if (taskDetailString.contains(searchKey)) {
				matched++;
			}
		}

		if (matched == expectedMatched) {
			hasMatched = true;
		}

		return hasMatched;
	}
	
	/*
	 * Determine the date for start and end date based
	 * on the task type
	 */
	public static void setStartEndDate(Task task, Date date, String text) {
		if (!text.equals(Constant.XML_TEXT_NIL)) {
			task.setStartDate(date);
			
			if (task.getTaskType().equals(TaskType.TIMED)) {
				task.setEndDate(task.getTo());
			} else {
				task.setEndDate(date);
			}			
		}
	}
	
	// -----------------------------------------------------------------------------------------------
	// Private Methods
	// -----------------------------------------------------------------------------------------------
	private String generateToDoString(String userInput) {
		String toDoString = userInput;
		
		toDoString = InputParser.removeCategoryFromString(toDoString, _category);		
		toDoString = InputParser.removePriorityFromString(toDoString, _priority);		
		toDoString = InputParser.removeRecurrenceFromString(toDoString, _isRecurring, _repeat);
		toDoString = InputParser.extractDescriptionFromString(toDoString, _taskType, _id);	
		
		return toDoString.trim(); 
	}

	private List<Date> getDates(String userInput) {
		String toBeRemoved = InputParser.extractDescriptionFromString(userInput, _taskType, _id);
		String detailsString = userInput.replace(toBeRemoved, "");
		
		List<Date> dates = Main.inputParser.getDatesFromString(detailsString);
		return dates;
	}
	
	private void setDatesForTaskType(List<Date> dates) {
		_on = null;
		_from = null;
		_to = null;
		_by = null;
		_endDate = null;
		
		switch(_taskType) {
			case EVENT :
				_on = dates.get(0);
				
				_startDate = _on;
				_endDate = _on;
				break;
			case TIMED :				
				_from = dates.get(0);
				_to = dates.get(1);
				
				_startDate= _from;
				_endDate = _to;
				break;
			case DATED :
				_by = dates.get(0);
				
				_startDate = _by;
				_endDate = _by;
				break;
			default :
				// floating task
				// does not require action since no date in array
				break;
		}
	}
	
	private void setTaskContentAttributes(String userInput, Task originalTask,
			  							  List<Date> dates) {
		setDatesForTaskType(dates);
		_category = InputParser.getCategoryFromString(userInput);

		boolean isValidOperation = processRecurrence(dates, userInput,
								   originalTask);
		if (isValidOperation) {
			_priority = InputParser.getPriorityFromString(userInput);
			_toDo = generateToDoString(userInput);
			_status = TaskStatus.getTaskStatus(_endDate);

			_isValid = true;
		}
	}
		
	// ---------------------------------------------------------
	// Recurring Tasks-related details tags
	// ---------------------------------------------------------
	private boolean processRecurrence(List<Date> dates, String userInput, Task originalTask) {
		_recurringTasks = new ArrayList<RecurringTask>();
		_isRecurring = false;
		_repeatUntil = null;
		_repeat = Frequency.NIL;
		_repeatDay = -1;
		
		boolean isValid = true;
		Command recurringCommand = Command.verifyRecurringCommands(userInput);
		if (RecurringTask.isValidRecurringTaskType(_taskType)) {
			Date untilDate = InputParser.getUntilDateFromString(userInput);
			
			if (recurringCommand != null &&
				untilDate != null && 
				DateParser.isBeforeDate(untilDate, _endDate)) { 
				// user attempted to create a recurring task with invalid until date
				isValid = false;
				Main.systemFeedback = Constant.MSG_INVALID_UNTIL_DATE;				
				
			} else if (recurringCommand == null) { 				
				isValid = verifyUserInputForRecurrence(userInput, isValid,
						  untilDate);
			} else {
				if (dates != null) {
					isValid = true;	
					setRecurrenceDetails(dates, originalTask, recurringCommand, untilDate);									
				} else {
					isValid = false;
					Main.systemFeedback = Constant.MSG_INVALID_RECURRING;
				}
			}
		} else if (recurringCommand != null) {
			isValid = false;
			Main.systemFeedback = Constant.MSG_INVALID_RECURRING;
		}
				
		return isValid;
	}

	/*
	 * returns true if the user input is a valid operation
	 * returns false if it is a recurrence type command but has no until date
	 */
	private boolean verifyUserInputForRecurrence(String userInput,
												 boolean isValid, Date untilDate) {
		boolean hasRecurringCommands = Command.hasRecurringCommands(userInput);
		
		if (hasRecurringCommands && untilDate == null) {
			isValid = false;
			Main.systemFeedback = Constant.MSG_NO_UNTIL_DATE;			
		} else if (!hasRecurringCommands && untilDate == null) { 
			isValid = true; 
		}
		return isValid;
	}

	private void setRecurrenceDetails(List<Date> dates, Task originalTask,
									 Command recurringCommand, Date untilDate) {
		_isRecurring = true;
		_repeatUntil = untilDate;
		_repeat = Frequency.getFrequency(recurringCommand);	
		
		Date startDate = dates.get(0);
		_repeatDay = DateParser.calculateDayOfWeek(startDate);
		
		generateRecurringTasks(startDate, originalTask);
	}		

	/*
	 * Generate recurring child tasks based on the frequency chosen
	 */
	private void generateRecurringTasks(Date startDate, Task originalTask) {
		Calendar calendarStart = DateParser.createCalendar(startDate);
		Calendar calendarEnd = DateParser.createCalendar(_repeatUntil);
		int startDateDayOfMonth = DateParser.calculateDayOfMonth(calendarStart);
		int startDateMonth = DateParser.calculateMonth(calendarStart);
		
		ArrayList<RecurringTask> recurringTasks = null;
		if (originalTask != null) {
			recurringTasks = originalTask.getRecurringTasks();
		}
				
		while (calendarStart.before(calendarEnd) || calendarStart.equals(calendarEnd)) {
			switch (_repeat) {
				case DAILY :
					if (hasAddedDailyRecurringTask(calendarStart, recurringTasks)) {
						continue;
					}
					break;
				case WEEKLY :
					if (hasAddedWeeklyRecurringTask(calendarStart, recurringTasks)) {
						continue;
					}
					break;
				case MONTHLY :
					if (hasAddedMonthlyRecurringTask(calendarStart, startDateDayOfMonth, 
													 recurringTasks)) {
						continue;
					}
					break;
				case YEARLY :
					if (hasAddedYearlyRecurringTask(calendarStart, startDateDayOfMonth, 
													startDateMonth, recurringTasks)) {
						continue;
					}
					break;					
				default :
					// invalid task object
					return;
			}
			
			calendarStart.add(Calendar.DAY_OF_MONTH, 1);
		}
	}

	private boolean hasAddedYearlyRecurringTask(Calendar calendarStart, 
												int startDateDayOfMonth, 
												int startDateMonth,
												ArrayList<RecurringTask> recurringTasks) {
		boolean hasAdded = false;
		int dayOfMonth;
		int month;
		dayOfMonth = DateParser.calculateDayOfMonth(calendarStart);	
		month = DateParser.calculateMonth(calendarStart);
		
		if (dayOfMonth == startDateDayOfMonth &&
			month == startDateMonth) {
			addToRecurringTasks(calendarStart, recurringTasks);
			
			calendarStart.add(Calendar.YEAR, 1);
			hasAdded = true;
		}
		
		return hasAdded;
	}

	private boolean hasAddedMonthlyRecurringTask(Calendar calendarStart, int startDateDayOfMonth,
												 ArrayList<RecurringTask> recurringTasks) {
		boolean hasAdded = false;
		int dayOfMonth = DateParser.calculateDayOfMonth(calendarStart);	
		
		if (dayOfMonth == startDateDayOfMonth) {
			addToRecurringTasks(calendarStart, recurringTasks);
			
			calendarStart.add(Calendar.MONTH, 1);
			hasAdded = true;
		}
		
		return hasAdded;
	}

	private boolean hasAddedWeeklyRecurringTask(Calendar calendarStart, 
												ArrayList<RecurringTask> recurringTasks) {
		boolean hasAdded = false;
		int dayOfWeek = DateParser.calculateDayOfWeek(calendarStart);
		
		if (dayOfWeek == _repeatDay) {
			addToRecurringTasks(calendarStart, recurringTasks);
			
			calendarStart.add(Calendar.WEEK_OF_YEAR, 1);
			hasAdded = true;
		}
		
		return hasAdded;
	}
	
	private boolean hasAddedDailyRecurringTask(Calendar calendarStart, 
												ArrayList<RecurringTask> recurringTasks) {
		boolean hasAdded = true;
		addToRecurringTasks(calendarStart, recurringTasks);

		calendarStart.add(Calendar.DATE, 1);

		return hasAdded;
	}
	
	private void addToRecurringTasks(Calendar calendarStart, 
									 ArrayList<RecurringTask> recurringTasks) {
		String recurringTaskId = generateRecurringTaskId();
		RecurringTask recurringTask = 
				new RecurringTask(recurringTaskId, calendarStart);
		
		if (recurringTasks != null) {
			useOriginalRecurTaskStatus(recurringTasks, recurringTask);
		}
		
		_recurringTasks.add(recurringTask);
	}

	/*
	 * If the date and time of the new recurring task is a match
	 * to the original entry, take the original status.
	 */
	private void useOriginalRecurTaskStatus(ArrayList<RecurringTask> recurringTasks, 
											RecurringTask recurringTask) {
		boolean hasMatched = false;
		
		Date thisRecurDate = recurringTask.getRecurDate();
		Date thatRecurDate = null;
		
		for (RecurringTask recTask : recurringTasks) {
			thatRecurDate = recTask.getRecurDate();
			hasMatched = DateParser.hasMatchedDateTime(thisRecurDate, thatRecurDate);
			
			if (hasMatched) {
				recurringTask.setStatus(recTask.getStatus());
				
				break;
			}
		}
	}
	
	private String generateRecurringTaskId() {
		return String.valueOf(_recurringTasks.size() + 1);
	}
}

	// End of segment: C:\Users\Ruyi\Desktop\collate\source\application\Task.java





	/**
	 * origin: C:\Users\Ruyi\Desktop\collate\source\application\TaskStatus.java
	 */

package application;

import java.util.Date;

public enum TaskStatus {
	ERROR,
	COMPLETED,
	ONGOING,
	OVERDUE,
	DELETED;
	
	public static TaskStatus getTaskStatus(Date endDate) {
		TaskStatus status = TaskStatus.OVERDUE;		
		
		if (endDate == null) { // floating task
			return TaskStatus.ONGOING;
		} else {
			Date todayDate = new Date();
			boolean isOngoing = DateParser.isBeforeDate(todayDate, endDate);
			
			if (isOngoing) {
				status = TaskStatus.ONGOING;
			}
		}
		
		return status;
	}
}

	// End of segment: C:\Users\Ruyi\Desktop\collate\source\application\TaskStatus.java





	/**
	 * origin: C:\Users\Ruyi\Desktop\collate\source\application\TaskType.java
	 */

package application;
public enum TaskType {
	TIMED, 
	DATED, 
	FLOATING, 
	EVENT,
	INVALID;

	public static TaskType verifyTaskType(String commandLine) {
		if (isEvent(commandLine)) {
			return TaskType.EVENT;
		} else if (isTimedTask(commandLine)) {
			return TaskType.TIMED;
		} else if (isDatedTask(commandLine)) {
			return TaskType.DATED;
		} else if (isFloatingTask(commandLine)) {
			return TaskType.FLOATING;
		} else {
			return TaskType.INVALID;
		}
	}
	
	public static boolean isEvent(String commandLine) {
		String lowerCase = commandLine.toLowerCase();
		String basicCmd = Command.ON.getBasicCommand() + " ";
		String advancedCmd = Command.ON.getAdvancedCommand() + " ";
		
		return (lowerCase.contains(basicCmd) ||
				lowerCase.contains(advancedCmd));
	}

	public static boolean isTimedTask(String commandLine) {
		String lowerCase = commandLine.toLowerCase();
		String basicFromCmd = Command.FROM.getBasicCommand() + " ";
		String advancedFromCmd = Command.FROM.getAdvancedCommand() + " ";
		String basicToCmd = Command.TO.getBasicCommand() + " ";
		String advancedToCmd = Command.TO.getAdvancedCommand() + " ";
				
		return ((lowerCase.contains(basicFromCmd) ||
				 lowerCase.contains(advancedFromCmd)) &&
				(lowerCase.contains(basicToCmd) ||
				 lowerCase.contains(advancedToCmd)));
	}
	
	public static boolean isDatedTask(String commandLine) {
		String lowerCase = commandLine.toLowerCase();
		String basicCmd = Command.BY.getBasicCommand() + " ";
		String advancedCmd = Command.BY.getAdvancedCommand() + " ";
		
		return (lowerCase.contains(basicCmd) ||
				lowerCase.contains(advancedCmd));
	}
	
	public static boolean isFloatingTask(String commandLine) {
		return (!(isEvent(commandLine) && isTimedTask(commandLine) &&
				 isDatedTask(commandLine)));
	}
	
	public Command getDateCommand() {
		Command dateCommand = null;
		
		switch(this) {
			case EVENT :	
				dateCommand = Command.ON;
				break;
			case TIMED :				
				dateCommand = Command.FROM;
				break;
			case DATED :
				dateCommand = Command.BY;
				break;
			default :
				// floating task
				// no need to do anything since there is no date
				break;
		}
		
		return dateCommand;
	}
}

	// End of segment: C:\Users\Ruyi\Desktop\collate\source\application\TaskType.java





	/**
	 * origin: C:\Users\Ruyi\Desktop\collate\source\application\ToDoList.java
	 */

package application;
import java.io.File;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.Iterator;
import javafx.util.Pair;
import org.w3c.dom.Document;
import test.ToDoListTest;

public class ToDoList {
	private int _nextId;
	private String _listFilePath;
	private ArrayList<Task> _tasks;
	private ArrayList<String> _categories;
	private Task _selectedTask;
	
	// -----------------------------------------------------------------------------------------------
	// Constructors
	// -----------------------------------------------------------------------------------------------
	public ToDoList() {				
		_listFilePath = Main.storage.readSavePath();		
		
		createListFileIfNotExist();	
		
		_nextId = Main.storage.readNextId();
		_tasks = Main.storage.loadTasksXmlToArrayList();
		_categories = Main.storage.loadCategoriesXmlToArrayList();
	}
	
	/*
	 * Created for unit testing
	 */
	public ToDoList(boolean isTest) {
		String testListPath = ToDoListTest.PATH_TEST_FILE;
		
		if (isTest) {
			_listFilePath = testListPath;
			
			createListFileIfNotExist();	
			
			_nextId = Main.storage.readNextId();
			_tasks = Main.storage.loadTasksXmlToArrayList();
			_categories = Main.storage.loadCategoriesXmlToArrayList();
		}
	}
	
	// -----------------------------------------------------------------------------------------------
	// Get Methods
	// -----------------------------------------------------------------------------------------------
	public String getListFilePath() {
		return _listFilePath;
	}
	
	public ArrayList<Task> getTasks() {
		return _tasks;
	}
	
	public int getNextId() {
		return _nextId;
	}
	
	public ArrayList<String> getCategories() {
		return _categories;
	}
	
	public Task getSelectedTask() {
		return _selectedTask;
	}
	
	
	// -----------------------------------------------------------------------------------------------
	// Set Methods
	// -----------------------------------------------------------------------------------------------
	public void setListFilePath(String listFilePath) {
		_listFilePath = listFilePath;
	}	

	public void setTasks(ArrayList<Task> tasks) {
		_tasks = tasks;
	}

	public void setNextId(int nextId) {
		_nextId = nextId;
	}

	public void setCategories(ArrayList<String> categories) {
		_categories = categories;
	}
	
	public void setSelectedTask(Task selectedTask) {
		_selectedTask = selectedTask;
	}

	
	// -----------------------------------------------------------------------------------------------
	// Public Methods
	// -----------------------------------------------------------------------------------------------
	// ---------------------------------------------------------
	// Add-related methods
	// ---------------------------------------------------------
	public String addTaskToList(Task task) {	
		ArrayList<Task> backupList = addToArrayListAndBackup(task);		
		String result = writeListToFile(task, backupList);
		
		return result;
	}
		
	public Pair<String, Task> addTaskBackToList(Task task, boolean isUndo) {
		Task removedTask = null;
		if (task.getIsRecurring() && isUndo) {
			Pair<Task, String> deleteDetailsPair = deleteTaskById(task.getId());
			removedTask = deleteDetailsPair.getKey();
		}
			
		String result = addTaskToList(task);
		
		return new Pair<String, Task>(result, removedTask);
	}
	
	// ---------------------------------------------------------
	// Delete-related methods
	// ---------------------------------------------------------
	public Pair<Task, String> deleteTaskFromList(String userInput) {
		String targetId = InputParser.getTargetIdFromString(userInput);
				
		Pair<Task, String> deleteDetailsPair = deleteTaskById(targetId);
		
		return deleteDetailsPair;
	}
	
	public Pair<Task, String> deleteTaskById(String targetId) {
		if (targetId == null) {
			return null;
		}
		
		String taskId = targetId;
		String recurringTaskId = null;
		Task task = null;
		Task removedTask = null;
		int index = 0;		
		boolean isFound = false;
		Iterator<Task> taskIterator = _tasks.iterator();
		
		boolean isRecurringTaskId = targetId.contains(Constant.PREFIX_RECURRING_ID);					
		if (isRecurringTaskId) {			
			recurringTaskId = InputParser.getChildIdFromRecurringId(targetId);			
			taskId = InputParser.getTaskIdFromRecurringId(targetId);
		}
		
		while (taskIterator.hasNext()) {
			task = taskIterator.next();
			
			isFound = (task.getId().equals(taskId));
			
			if (isFound) {			
				ArrayList<Task> backupList = deepCloneArrayList(_tasks);
				removedTask = backupList.get(index);
				
				if (isRecurringTaskId) {
					task.deleteRecurringTaskById(recurringTaskId);
				} else {
					_tasks.remove(index);
				}
				
				_tasks = TaskSorter.getTasksSortedByDate(_tasks);
				writeListToFile(task, backupList);
				
				break;
			}
			
			index++;
		}
		
		return new Pair<Task, String>(removedTask, recurringTaskId);
	}
	
	// End of segment: C:\Users\Ruyi\Desktop\collate\source\application\ToDoList.java





	/**
	 * origin: C:\Users\Ruyi\Desktop\collate\source\application\Undo.java
	 */

package application;

import javafx.util.Pair;

public class Undo {
	private Command _undoCommand;
	private Task _originalTask;
	private String _targetId;
	
	// -----------------------------------------------------------------------------------------------
	// Constructors
	// -----------------------------------------------------------------------------------------------
	// to undo delete
	public Undo(Command toUndo, Task originalTask) {
		this(toUndo, originalTask, null);
	}
	
	// to undo add
	public Undo(Command toUndo, String targetId) {
		this(toUndo, null, targetId);
	}
	
	// to undo update / complete / deletion of recurring task
	public Undo(Command toUndo, Task originalTask, String targetId) {
		_undoCommand = getUndoCommand(toUndo);
		_originalTask = originalTask;
		_targetId = targetId;
	}
	
	// -----------------------------------------------------------------------------------------------
	// Get methods
	// -----------------------------------------------------------------------------------------------
	private Command getUndoCommand(Command toUndo) {
		Command command = null;
		
		switch (toUndo) {
			case ADD :
				command = Command.DELETE;
				break;
			case DELETE :
				command = Command.ADD;
				break;
			case UPDATE :
				command = Command.UPDATE;
				break;
			case COMPLETE :
				command = Command.COMPLETE;
				break;
			default:
				// no undo command
				// return null
				break;
		}
		
		return command;
	}
	
	// -----------------------------------------------------------------------------------------------
	// Undo-related methods
	// -----------------------------------------------------------------------------------------------
	public static void prepareUndoAdd(Task task) {
		Undo undo = new Undo(Command.ADD, task.getId());
		Main.undos.push(undo);				
		Main.redos.clear();
	}	
	
	public static void prepareUndoDelete(Task removedTask, String targetId) {
		Undo undo = null;
		if (targetId == null) {
			undo = new Undo(Command.DELETE, removedTask);
		} else {
			undo = new Undo(Command.DELETE, removedTask, targetId);
		}
		
		Main.undos.push(undo);			
		Main.redos.clear();
	}
	
	public static void prepareUndoUpdate(Task originalTask, String targetId) {
		Undo undo = new Undo(Command.UPDATE, originalTask, targetId);
		Main.undos.push(undo);
		Main.redos.clear();
	}
	
	public static void prepareUndoComplete(Task completedTask, String targetId) {
		Undo undo = new Undo(Command.COMPLETE, completedTask, targetId);
		Main.undos.push(undo);
		Main.redos.clear();
	}
	
	public String undoAction() {
		String systemMsg = null;
		
		switch (_undoCommand) {
			case ADD :
				// to undo delete action
				// add _originalTask
				systemMsg = undoDelete();
				break;
			case DELETE :
				// to undo add action
				// delete using _targetId
				systemMsg = undoAdd();
				break;
			case UPDATE :
			case COMPLETE:
				// to undo update action
				// update using _originalTask and _targetId
				systemMsg = undoUpdate();
				break;
			default:
				// no undo command
				// return null
				break;
		}
		
		return systemMsg;
	}

	private String undoUpdate() {
		String systemMsg;
		Task replacedTask = Main.list.replaceTaskOnList(_originalTask, _targetId);
		
		if (replacedTask != null) {
			Undo redo = new Undo(Command.UPDATE, replacedTask, _originalTask.getId());
			Main.redos.push(redo);
			
			systemMsg = Constant.MSG_UNDO_UPDATE_SUCCESS;
		} else {
			systemMsg = Constant.MSG_UNDO_UPDATE_FAIL;
		}
		return systemMsg;
	}

	private String undoAdd() {
		String systemMsg;
		Pair<Task, String> deleteDetailsPair = 
				Main.list.deleteTaskById(_targetId);
		Task removedTask = deleteDetailsPair.getKey();
		
		if (removedTask != null) {
			Undo redo = new Undo(Command.DELETE, removedTask);
			Main.redos.push(redo);
			
			systemMsg = Constant.MSG_UNDO_ADD_SUCCESS;
		} else {
			systemMsg = Constant.MSG_UNDO_ADD_FAIL;
		}
		return systemMsg;
	}

	private String undoDelete() {
		String systemMsg;
		
		Pair<String, Task> systemMsgWithRemovedTaskPair = null;
		if (_targetId == null) {
			systemMsgWithRemovedTaskPair = Main.list.	
										   addTaskBackToList(_originalTask, false);	
		} else {
			systemMsgWithRemovedTaskPair = Main.list.	
					      				   addTaskBackToList(_originalTask, true);	
		}
			
		
		systemMsg = systemMsgWithRemovedTaskPair.getKey();
		if (systemMsg.equals(Constant.MSG_ADD_SUCCESS)) {
			Task removedTask = systemMsgWithRemovedTaskPair.getValue();
			
			if (removedTask != null) {
				Undo redo = new Undo(Command.UPDATE, removedTask, _originalTask.getId());
				Main.redos.push(redo);
			} else {
				Undo redo = new Undo(Command.ADD, _originalTask.getId());
				Main.redos.push(redo);
			}
			
			systemMsg = Constant.MSG_UNDO_DELETE_SUCCESS;
		} else {
			systemMsg = Constant.MSG_UNDO_DELETE_FAIL;
		}
		return systemMsg;
	}
	
	// -----------------------------------------------------------------------------------------------
	// Redo-related methods
	// -----------------------------------------------------------------------------------------------
	public String redoAction() {
		String systemMsg = null;
		
		switch (_undoCommand) {
			case ADD :
				// to redo add action
				// add _originalTask
				systemMsg = redoAdd();
				break;
			case DELETE :
				// to redo delete action
				// delete using _targetId
				systemMsg = redoDelete();
				break;
			case UPDATE :
			case COMPLETE:
				// to redo update action
				// update using _originalTask and _targetId
				systemMsg = redoUpdate();
				break;
			default:
				// no undo command
				// return null
				break;
		}
		
		return systemMsg;
	}

	private String redoUpdate() {
		String systemMsg;
		Task replacedTask = Main.list.replaceTaskOnList(_originalTask, _targetId);
		
		if (replacedTask != null) {
			Undo undo = new Undo(Command.UPDATE, replacedTask, _originalTask.getId());
			Main.undos.push(undo);
			
			systemMsg = Constant.MSG_REDO_UPDATE_SUCCESS;
		} else {
			systemMsg = Constant.MSG_REDO_UPDATE_FAIL;
		}
		return systemMsg;
	}

	private String redoDelete() {
		String systemMsg;
		Pair<Task, String> deleteDetailsPair = 
				Main.list.deleteTaskById(_targetId);
		Task removedTask = deleteDetailsPair.getKey();
		
		if (removedTask != null) {
			Undo undo = new Undo(Command.DELETE, removedTask);
			Main.undos.push(undo);
			
			systemMsg = Constant.MSG_REDO_DELETE_SUCCESS;
		} else {
			systemMsg = Constant.MSG_REDO_DELETE_FAIL;
		}
		return systemMsg;
	}

	private String redoAdd() {
		String systemMsg;
		Pair<String, Task> systemMsgWithRemovedTaskPair = 
		   				   Main.list.addTaskBackToList(_originalTask, false);		

		systemMsg = systemMsgWithRemovedTaskPair.getKey();			
		if (systemMsg.equals(Constant.MSG_ADD_SUCCESS)) {
			Undo undo = new Undo(Command.ADD, _originalTask.getId());
			Main.undos.push(undo);
			
			systemMsg = Constant.MSG_REDO_ADD_SUCCESS;
		} else {
			systemMsg = Constant.MSG_REDO_ADD_FAIL;
		}
		return systemMsg;
	}
}


	// End of segment: C:\Users\Ruyi\Desktop\collate\source\application\Undo.java





	/**
	 * origin: C:\Users\Ruyi\Desktop\collate\source\application\XmlManager.java
	 */

package application;

import java.util.ArrayList;
import java.util.logging.Level;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.xpath.XPath;
import javax.xml.xpath.XPathFactory;

import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.w3c.dom.Text;

public class XmlManager {
	// -----------------------------------------------------------------------------------------------
	// Public Methods
	// -----------------------------------------------------------------------------------------------
	public static DocumentBuilder getNewDocBuilder() {		
		try {
			DocumentBuilderFactory documentFactory = 
					DocumentBuilderFactory.newInstance();
			
			return documentFactory.newDocumentBuilder();
		} catch (ParserConfigurationException exception) {
			Main.LOGGER.logp(Level.SEVERE, 
							 XmlManager.class.getName(), 
							 "getNewDocBuilder", 
							 exception.getMessage());
		}
		
		return null;
	}
		
	public static XPath getNewXPath() {
        XPathFactory xpathFactory = XPathFactory.newInstance();

        return xpathFactory.newXPath();
	}
	
	/*
	 * Create and initialize an XML document 
	 * with the file's global information tags
	 */
	public static Document initDocument() {
		Document document = XmlManager.createXmlDocument();
								
		Element root = document.createElement(Constant.TAG_FILE);
		document.appendChild(root);
		
		XmlManager.createAndAppendChildElement(document, root, 
									Constant.TAG_NEXT_ID, 
									String.valueOf(Constant.START_ID));
		
		Element categories = XmlManager.createAndAppendWrapper(document, root,
							    Constant.TAG_CATEGORIES);
		
		XmlManager.createAndAppendChildElement(document, categories, 
									Constant.TAG_CATEGORY, 
									String.valueOf(Constant.CATEGORY_UNCATEGORISED));
		
		XmlManager.createAndAppendWrapper(document, root, 
							   String.valueOf(Constant.TAG_TASKS));
		return document;
	}
	
	public static void createAndAppendChildElement(Document document,
												   Element parentElement, 
												   String tag, String content) {
		Element element = document.createElement(tag);
		Text text = document.createTextNode(content);
		element.appendChild(text);
		parentElement.appendChild(element);
	}

	public static Element createAndAppendWrapper(Document document,
										   		 Element parentElement, 
										   		 String tag) {
		Element element = document.createElement(tag);
		parentElement.appendChild(element);

		return element;
	}
	
	public static Task transformNodeToTask(Node node) {
		Task task = new Task();		
		Element element = (Element) node;
		
		String text = element.getAttribute(Constant.TAG_ATTRIBUTE_ID);
		task.setId(text);
		
		text = getTextByTagName(element, Constant.TAG_TYPE);
		task.setTaskType(TaskType.valueOf(text));		
		
		text = getTextByTagName(element, Constant.TAG_TODO);
		task.setToDo(text);
		
		text = getTextByTagName(element, Constant.TAG_ORIGINAL);
		task.setOriginalText(text);
		
		text = getTextByTagName(element, Constant.TAG_ON);
		task.setOn(Main.inputParser.getDateFromString(text));		
		Task.setStartEndDate(task, task.getOn(), text);
				
		text = getTextByTagName(element, Constant.TAG_FROM);
		task.setFrom(Main.inputParser.getDateFromString(text));
		
		text = getTextByTagName(element, Constant.TAG_TO);
		task.setTo(Main.inputParser.getDateFromString(text));
		Task.setStartEndDate(task, task.getFrom(), text);
		
		text = getTextByTagName(element, Constant.TAG_BY);
		task.setBy(Main.inputParser.getDateFromString(text));
		Task.setStartEndDate(task, task.getBy(), text);
		
		text = getTextByTagName(element, Constant.TAG_CATEGORY);
		task.setCategory(text);
		
		text = getTextByTagName(element, Constant.TAG_RECURRING);
		task.setIsRecurring(Boolean.valueOf(text));
		
		text = getTextByTagName(element, Constant.TAG_REPEAT);
		task.setRepeat(Frequency.valueOf(text));
		
		text = getTextByTagName(element, Constant.TAG_REPEAT_DAY);
		task.setRepeatDay(Integer.valueOf(text));
		
		text = getTextByTagName(element, Constant.TAG_REPEAT_UNTIL);
		task.setRepeatUntil(Main.inputParser.getDateFromString(text));
		
		text = getTextByTagName(element, Constant.TAG_PRIORITY);
		task.setPriority(Priority.valueOf(text));
		
		text = getTextByTagName(element, Constant.TAG_STATUS);
		task.setStatus(TaskStatus.valueOf(text));
				
		if (task.getIsRecurring()) {
			ArrayList<RecurringTask> recurringTasks = 
					transformRecurringTasksNodesToArrayList(element);
			task.setRecurringTasks(recurringTasks);
		}
		
		return task;
	}
	
	public static Element transformTaskToXml(Document document, Task task) {
		Element taskTag = document.createElement(Constant.TAG_TASK);
		taskTag.setAttribute(Constant.TAG_ATTRIBUTE_ID, task.getId());
		
		XmlManager.createAndAppendChildElement(document, taskTag, Constant.TAG_TYPE, 
											   task.getTaskType().toString());
		
		XmlManager.createAndAppendChildElement(document, taskTag, Constant.TAG_TODO, 
											   task.getToDo());
		
		XmlManager.createAndAppendChildElement(document, taskTag, Constant.TAG_ORIGINAL, 
											   task.getOriginalText());				
		
		XmlManager.createAndAppendChildElement(document, taskTag, Constant.TAG_ON, 
											   InputParser.getDateString(task.getOn()));	
		
		XmlManager.createAndAppendChildElement(document, taskTag, Constant.TAG_FROM, 
											   InputParser.getDateString(task.getFrom()));
		
		XmlManager.createAndAppendChildElement(document, taskTag, Constant.TAG_TO, 
											   InputParser.getDateString(task.getTo()));
		
		XmlManager.createAndAppendChildElement(document, taskTag, Constant.TAG_BY, 
											   InputParser.getDateString(task.getBy()));	
		
		XmlManager.createAndAppendChildElement(document, taskTag, Constant.TAG_CATEGORY, 
											   task.getCategory().toString());
		
		XmlManager.createAndAppendChildElement(document, taskTag, Constant.TAG_RECURRING, 
											   String.valueOf(task.getIsRecurring()));
		
		XmlManager.createAndAppendChildElement(document, taskTag, Constant.TAG_REPEAT, 
											   task.getRepeat().toString());
		
		XmlManager.createAndAppendChildElement(document, taskTag, Constant.TAG_REPEAT_DAY, 
											   String.valueOf(task.getRepeatDay()));	
		
		XmlManager.createAndAppendChildElement(document, taskTag, Constant.TAG_REPEAT_UNTIL, 
											   InputParser.getDateString(task.getRepeatUntil()));	
		
		XmlManager.createAndAppendChildElement(document, taskTag, Constant.TAG_PRIORITY, 
											   task.getPriority().toString());
		
		XmlManager.createAndAppendChildElement(document, taskTag, Constant.TAG_STATUS, 
				   							   task.getStatus().toString());
						
		createAndAppendRecurringTasksNodes(document, taskTag, task);
		
		return taskTag;
	}
	
	// -----------------------------------------------------------------------------------------------
	// Private Methods
	// -----------------------------------------------------------------------------------------------
	private static Document createXmlDocument() {
		try {
			DocumentBuilderFactory documentFactory = 
					DocumentBuilderFactory.newInstance();
			DocumentBuilder documentBuilder = 
					documentFactory.newDocumentBuilder();
			
			return documentBuilder.newDocument(); 
			
		} catch (ParserConfigurationException exception) {
			Main.LOGGER.logp(Level.SEVERE, 
							 XmlManager.class.getName(), 
							 "createXmlDocument", 
							 exception.getMessage());
		}		
		
		return null;
	}	
	
	private static String getTextByTagName(Element parentElement, String tagName) {
		return parentElement.getElementsByTagName(tagName).
			   item(0).
			   getTextContent();
	}
	
	/*
	 * Transform XML node to an arraylist of recurring task objects
	 */
	private static ArrayList<RecurringTask> transformRecurringTasksNodesToArrayList(Element element) {
		ArrayList<RecurringTask> recurringTasks = new ArrayList<RecurringTask>();
		
		Element recurringTasksWrapper = 
				(Element) element.getElementsByTagName(Constant.TAG_RECURRING_TASKS).
				item(0);
		
		NodeList recurringTasksNodes = recurringTasksWrapper.
									   getElementsByTagName(Constant.TAG_RECURRING_TASK);
		
		for (int i = 0; i < recurringTasksNodes.getLength(); i++) {
			RecurringTask recurringTask = transformNodeToRecurringTask(
					recurringTasksNodes, i);
			
			recurringTasks.add(recurringTask);
		}
				
		return recurringTasks;
	}

	/*
	 * Transform XML node to a recurring task object
	 */
	private static RecurringTask transformNodeToRecurringTask(
			NodeList recurringTasksNodes, int i) {
		RecurringTask recurringTask = new RecurringTask();
		Element recurringTaskNode = (Element) recurringTasksNodes.item(i);
		
		String text = recurringTaskNode.getAttribute(Constant.TAG_RECURRING_ID);
		recurringTask.setRecurringTaskId(text);
		
		text = getTextByTagName(recurringTaskNode, Constant.TAG_RECURRING_STATUS);
		recurringTask.setStatus(TaskStatus.valueOf(text));		
		
		text = getTextByTagName(recurringTaskNode, Constant.TAG_RECURRING_DATE);
		recurringTask.setRecurDate(Main.inputParser.getDateFromString(text));
		return recurringTask;
	}
	
	/*
	 * Transform recurring task objects to XML nodes
	 */
	private static void createAndAppendRecurringTasksNodes(Document document, Element taskTag, Task task) {
		if (task.getIsRecurring()) {
			Element recurringTasksWrapper = XmlManager.createAndAppendWrapper(document, taskTag, 
					   						String.valueOf(Constant.TAG_RECURRING_TASKS));
						
			ArrayList<RecurringTask> recurringTasks = task.getRecurringTasks();
			
			
			for (RecurringTask recurringTask : recurringTasks) {
				Element recurringTaskTag = createRecurringTaskNode(document,
						recurringTask);	
				
				recurringTasksWrapper.appendChild(recurringTaskTag);
			}
		}
	}

	/*
	 * Transform recurring task object to XML node
	 */
	private static Element createRecurringTaskNode(Document document,
			RecurringTask recurringTask) {
		Element recurringTaskTag = document.createElement(Constant.TAG_RECURRING_TASK);
		recurringTaskTag.setAttribute(Constant.TAG_RECURRING_ID, recurringTask.getRecurringTaskId());
		
		XmlManager.createAndAppendChildElement(document, recurringTaskTag, 
											   Constant.TAG_RECURRING_STATUS, 
											   recurringTask.getStatus().toString());		
		
		XmlManager.createAndAppendChildElement(document, recurringTaskTag, 
											   Constant.TAG_RECURRING_DATE, 
											   InputParser.getDateString(recurringTask.getRecurDate()));
		return recurringTaskTag;
	}
	
	
}

	// End of segment: C:\Users\Ruyi\Desktop\collate\source\application\XmlManager.java





	/**
	 * origin: C:\Users\Ruyi\Desktop\collate\source\controller\HeaderController.java
	 */

	public void initMainController(MainController mainController) {
		mainCon = mainController;		
		addTextAreaListener();		
	}
	
	@FXML
	public void processCmd(KeyEvent keyEvent) throws IOException {			
		if (keyEvent.getCode() == KeyCode.ENTER) {		
			mainCon.showCorrectView();
			
			String userInput = textArea.getText();							   
			if (userInput.equals("")) {
				return;
			}
			
			String systemMsg = Execution.executeUserInput(userInput);
			if (systemMsg.equals(Constant.MSG_ORIGINAL_NOT_RETRIEVED)) {
				resetTextArea();
			}	
									
			mainCon.loadListsInTabs();
			mainCon.setSystemMessage(systemMsg);
		} 			
	}
	
	@FXML
	public void processCmdMouse(MouseEvent mouseEvent) throws IOException {			
		mainCon.showCorrectView();
		
		String userInput = textArea.getText();							   
		if (userInput.equals("")) {
			return;
		}
		
		String systemMsg = Execution.executeUserInput(userInput);
		if (systemMsg.equals(Constant.MSG_ORIGINAL_NOT_RETRIEVED)) {
			resetTextArea();
		}	
								
		mainCon.loadListsInTabs();
		mainCon.setSystemMessage(systemMsg);			
	}
	
	public void onTextChanged() {	
		textArea.clearStyle(0);		
		String textAreaText = textArea.getText();
		
		boolean toReset = textAreaText.trim().equals("");
		if (toReset) {
			resetTextArea();
		}
		
		if (Main.shouldResetCaret) {
			textArea.positionCaret(textAreaText.length() - 1);
			Main.shouldResetCaret = false;
		}
		
		highlightKeyWords();
	}
		
	public void resetTextArea() {
		Main.toUpdate = false;	

		textArea.clearStyle(0);
		textArea.clear();
		textArea.positionCaret(0);		
	}
		
	// End of segment: C:\Users\Ruyi\Desktop\collate\source\controller\HeaderController.java





	/**
	 * origin: C:\Users\Ruyi\Desktop\collate\source\controller\HeaderController.java
	 */

	private void highlightKeyWords() {		
		String inputString = textArea.getText();
		String lowerCase = inputString.toLowerCase();
		
		highlightActionCommands(lowerCase);
		highlightDatesCommands(lowerCase);
		highlightCategory(lowerCase);
		highlightPriority(lowerCase);
		highlightRecurringCommands(lowerCase);
		highlightSearchAttributes(lowerCase);
	}
	
	private void highlightRecurringCommands(String lowerCase) {
		String basicCommand = null;
		String advancedCommand = null;
		int startIndex = -1;
		int endIndex = -1;
		
		for (Command command : Constant.COMMAND_RECURRING) {
			basicCommand = command.getBasicCommand() + " " + 
						   Command.RECURRING_UNTIL.getBasicCommand() + " ";
			advancedCommand = command.getAdvancedCommand() + " " +
							  Command.RECURRING_UNTIL.getAdvancedCommand() + " ";;
			
			if (lowerCase.contains(basicCommand)) {
				startIndex = lowerCase.indexOf(basicCommand);
				endIndex = startIndex + basicCommand.length();
				
			} else if (lowerCase.contains(advancedCommand)) {
				startIndex = lowerCase.indexOf(advancedCommand);
				endIndex = startIndex + advancedCommand.length();
			}
			
			if (startIndex != -1 && endIndex != -1) {
				textArea.setStyleClass(startIndex, endIndex, 
									   Constant.CSS_CLASS_RECURRING_COMMANDS);			
				break;
			} 
			
			startIndex = -1;
			endIndex = -1;
		}
	}
	
	private void highlightPriority(String lowerCase) {
		String basicCommand = null;
		String advancedCommand = null;
		int startIndex = -1;
		int endIndex = -1;
		
		for (Command command : Constant.COMMAND_PRIORITIES) {
			basicCommand = command.getBasicCommand();
			advancedCommand = command.getAdvancedCommand();
			
			startIndex = command.getIndexOfCommand(lowerCase);
			if (lowerCase.contains(basicCommand)) {
				endIndex = startIndex + basicCommand.length();				
			} else if (lowerCase.contains(advancedCommand)) {
				endIndex = startIndex + advancedCommand.length();
			}
			
			if (startIndex != -1 && endIndex != -1) {
				textArea.setStyleClass(startIndex, endIndex, 
									   Constant.CSS_CLASS_PRIORITY);			
				break;
			} 
			
			startIndex = -1;
			endIndex = -1;
		}
	}
	
	private void highlightCategory(String lowerCase) {
		String lowerCaseTemp = lowerCase + " ";
		String basicCommand = Command.CATEGORY.getBasicCommand();
		int startIndex = -1;
		int endIndex = -1;
		
		if (lowerCaseTemp.contains(basicCommand)) {			
			startIndex = lowerCaseTemp.indexOf(basicCommand);
			endIndex = lowerCaseTemp.length();
			
			lowerCaseTemp = lowerCaseTemp.substring(startIndex, endIndex);
			endIndex = startIndex + lowerCaseTemp.indexOf(" ");
			textArea.setStyleClass(startIndex, endIndex, Constant.CSS_CLASS_CATEGORY);
		}
	}
	
	private void highlightDatesCommands(String lowerCase) {
		String basicCommand = null;
		String advancedCommand = null;
		int startIndex = -1;
		int endIndex = -1;
		
		for (Command command : Constant.COMMAND_DATES) {						
			basicCommand = command.getBasicCommand() + " ";
			advancedCommand = command.getAdvancedCommand() + " ";
			
			startIndex = command.getIndexOfCommand(lowerCase);
			if (lowerCase.contains(basicCommand)) {
				endIndex = startIndex + basicCommand.length();
				
			} else if (lowerCase.contains(advancedCommand)) {
				endIndex = startIndex + advancedCommand.length();
			}
			
			if (startIndex != -1 && endIndex != -1) {			
				textArea.setStyleClass(startIndex, endIndex, 
						   Constant.CSS_CLASS_DATE_COMMANDS);				
			} 
			
			startIndex = -1;
			endIndex = -1;
		}
	}
	
	private void highlightActionCommands(String lowerCase) {
		String basicCommand = null;
		String advancedCommand = null;
		int startIndex = -1;
		int endIndex = -1;
		
		for (Command command : Constant.COMMAND_ACTIONS) {
			basicCommand = command.getBasicCommand() + " ";
			advancedCommand = command.getAdvancedCommand() + " ";
			
			startIndex = command.getIndexOfCommand(lowerCase);
			if (lowerCase.contains(basicCommand) && 
				startIndex == 0) {
				endIndex = startIndex + basicCommand.length();
				
			} else if (lowerCase.contains(advancedCommand) &&
					   startIndex == 0) {
				endIndex = startIndex + advancedCommand.length();
			}
			
			if (startIndex != -1 && endIndex != -1) {
				textArea.setStyleClass(startIndex, endIndex, 
									   Constant.CSS_CLASS_ACTION_COMMANDS);			
				break;
			} 
			
			startIndex = -1;
			endIndex = -1;
		}
	}
			
	private void highlightSearchAttributes(String lowerCase) {
		String command = null;
		int startIndex = -1;
		int endIndex = -1;
		
		for (SearchAttribute searchAttribute : SearchAttribute.values()) {
			command = searchAttribute.getCommand();
			
			if (lowerCase.contains(command)) {
				startIndex = lowerCase.indexOf(command);
				endIndex = startIndex + command.length();
			} 
			
			if (startIndex != -1 && endIndex != -1) {
				textArea.setStyleClass(startIndex, endIndex, 
									   Constant.CSS_CLASS_SEARCH_ATTRIBUTES);			
			} 
			
			startIndex = -1;
			endIndex = -1;
		}
	}
	
	private void addTextAreaListener() {
		textArea.textProperty().addListener(new ChangeListener<String>() {
			@Override
		    public void changed(ObservableValue<? extends String> observable, 
		    					String oldValue, String newValue) {
				onTextChanged();
		    }
		});
	}
}

	// End of segment: C:\Users\Ruyi\Desktop\collate\source\controller\HeaderController.java





	/**
	 * origin: C:\Users\Ruyi\Desktop\collate\source\controller\MainController.java
	 */

	@FXML
	public void initialize() {
		initControllers();
		cleanCompletedTasks();
		Execution.executeCleanCategories();
		loadListsInTabs();
		initTutorialPopup();
		
		selectionModel = bodyController.tPaneMain.
						 getSelectionModel();
		
		Execution.executeStatusCheckTimerTask();
	}
	
	@FXML
	public void onShortcutKey(KeyEvent keyEvent) {	
		scrollList(keyEvent);		
		revertAction(keyEvent); 		
		switchTab(keyEvent);		
		navigateView(keyEvent);		
		showTutorial(keyEvent);
		showOpenFileDialog(keyEvent);
	}
	
	public void showCorrectView() {
		if (settingController.anPaneSetting.isVisible() ||
			searchResultController.anPaneSearchResult.isVisible()) {
			executeGoBack();
		}
	}
	
	// End of segment: C:\Users\Ruyi\Desktop\collate\source\controller\MainController.java





	/**
	 * origin: C:\Users\Ruyi\Desktop\collate\source\controller\MainController.java
	 */

	private void initTutorialPopup() {
		InputStream inputStream = getClass().getResourceAsStream(Constant.IMAGE_TUTORIAL);
		Image image = new Image(inputStream);
		ImageView imageView = new ImageView(image);
		
		tutorialPopup = new Popup();
		tutorialPopup.getContent().add(imageView);
	}
	
	private void initControllers() {
		headerController.initMainController(this);
		bodyController.initMainController(this);
		searchResultController.initMainController(this);
		settingController.initMainController(this);
		
		Execution.mainController = this;
		Execution.headerController = headerController;
		Execution.settingController = settingController;
	}

	private void scrollList(KeyEvent keyEvent) {
		boolean shouldReturn = !(Constant.SHORTCUT_PAGE_DOWN.match(keyEvent) ||
								 Constant.SHORTCUT_TA_UNFOCUSED_PAGE_DOWN.match(keyEvent) ||
								 Constant.SHORTCUT_PAGE_UP.match(keyEvent) ||
								 Constant.SHORTCUT_TA_UNFOCUSED_PAGE_UP.match(keyEvent));
		if (shouldReturn) {
			return;
		}
		
		String tabAllId = bodyController.tabAll.getId();
		String tabCategoryId = bodyController.tabCategory.getId();
		String tabPriorityId = bodyController.tabPriority.getId();
		
		Tab selectedTab = selectionModel.getSelectedItem();			
		String selectedTabId = selectedTab.getId();
		ScrollPane targetScrollPane = null;	
		
		if (selectedTabId.equals(tabAllId)) {
			targetScrollPane = bodyController.sPaneAll;
		} else if (selectedTabId.equals(tabCategoryId)) {
			targetScrollPane = bodyController.sPaneCategory;
		} else if (selectedTabId.equals(tabPriorityId)) {
			targetScrollPane = bodyController.sPanePriority;
		}
		
		if (targetScrollPane == null) {
			return;
		}
				
		setScrollPaneVvalue(keyEvent, targetScrollPane);
	}

	/*
	 * Set the position of the scroll pane based on
	 * the key pressed
	 */
	private void setScrollPaneVvalue(KeyEvent keyEvent, ScrollPane targetScrollPane) {
		double currentPosition = targetScrollPane.getVvalue();
		double newPosition = currentPosition;
		
		if (Constant.SHORTCUT_PAGE_DOWN.match(keyEvent) || 
			Constant.SHORTCUT_TA_UNFOCUSED_PAGE_DOWN.match(keyEvent)) {
			
			newPosition = currentPosition + Constant.POSITION_OFFSET_VERTICAL;
		} else if (Constant.SHORTCUT_PAGE_UP.match(keyEvent) || 
				   Constant.SHORTCUT_TA_UNFOCUSED_PAGE_UP.match(keyEvent)) {
			
			newPosition = currentPosition - Constant.POSITION_OFFSET_VERTICAL;
		}
		
		targetScrollPane.setVvalue(newPosition);
	}

	private void showOpenFileDialog(KeyEvent keyEvent) {
		if (Constant.SHORTCUT_OPEN_FILE_DIALOG.match(keyEvent)) {
			if (settingController.anPaneSetting.isVisible()) {
				settingController.openFileDialog();
			}
			
		}
	}
	
	private void showTutorial(KeyEvent keyEvent) {
		if (Constant.SHORTCUT_TUTORIAL.match(keyEvent)) {
			if (tutorialPopup.isFocused()) {
				tutorialPopup.hide();
			} else {
				double positionX = Main.priStage.getX() + 
								   Constant.POSITION_OFFSET_X_POPUP;							
				double positionY = (Main.priStage.getY() - 
									headerController.textArea.getLayoutY()) * 
								    Constant.POSITION_OFFSET_Y_POPUP;
				
				tutorialPopup.show(Main.priStage, positionX, positionY);
			}
		}
	}

	private void navigateView(KeyEvent keyEvent) {
		if (Constant.SHORTCUT_GO_BACK.match(keyEvent)) {
			executeGoBack();
		} else if (Constant.SHORTCUT_SETTING.match(keyEvent)) {
			executeSetting();				
		}
	}
	

	private void revertAction(KeyEvent keyEvent) {
		if (Constant.SHORTCUT_UNDO.match(keyEvent)) {
			String systemMsg = Execution.executeUndo();
			
			loadListsInTabs();
			setSystemMessage(systemMsg);
		} else if (Constant.SHORTCUT_REDO.match(keyEvent)) {
			String systemMsg = Execution.executeRedo();
			
			loadListsInTabs();
			setSystemMessage(systemMsg);
		}
	}
		

	private void switchTab(KeyEvent keyEvent) {
		if (Constant.SHORTCUT_TAB_ALL.match(keyEvent)) {
			selectionModel.select(Constant.TAB_INDEX_ALL);	
			
		} else if (Constant.SHORTCUT_TAB_CATEGORY.match(keyEvent)) {
			selectionModel.select(Constant.TAB_INDEX_CATEGORY);		
			
		} else if (Constant.SHORTCUT_TAB_PRIORITY.match(keyEvent)) {
			selectionModel.select(Constant.TAB_INDEX_PRIORITY);			
		}
	}
	
	
	// End of segment: C:\Users\Ruyi\Desktop\collate\source\controller\MainController.java





	/**
	 * origin: C:\Users\Ruyi\Desktop\collate\source\test\ExecutionTest.java
	 */

package test;

import static org.junit.Assert.*;

import java.io.File;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;

import org.junit.Test;

import application.Constant;
import application.Execution;
import application.Main;
import application.ToDoList;

public class ExecutionTest {
	private static final String TEST_ADD_COMMAND = "Have dinner with Amy /on Monday //friend /*";
	private static final String TEST_DELETE_COMMAND = "delete 1";
	public static final String PATH_TEST_FILE = "testFile.xml";
	
	private String originalSavePath;
	
	@Test
	public void test() {
		initTest();
		testAdd();
		testUndo();
		testRedo();
		testDelete();
		
		cleanTestFromSystem();
	}
	
	public void testAdd() {
		String methodName = "executeAdd";
		Class[] paramTypes = new Class[] {
				String.class
		};			
		Object[] params = new Object[] { 
				TEST_ADD_COMMAND 		
		};
		
		String expectedResult = Constant.MSG_ADD_SUCCESS;
		String actualResult = invokeMethod(methodName, paramTypes, params);
		
		assertEquals(actualResult, expectedResult);
	}
	
	public void testDelete() {
		// delete existing item
		String methodName = "executeDelete";
		Class[] paramTypes = new Class[] {
				String.class
		};			
		Object[] params = new Object[] { 
				TEST_DELETE_COMMAND 		
		};
		
		String expectedResult = Constant.MSG_DELETE_SUCCESS;
		String actualResult = invokeMethod(methodName, paramTypes, params);
		
		assertEquals(actualResult, expectedResult);
		
		// delete non-existing item
		expectedResult = Constant.MSG_ITEM_NOT_FOUND;
		actualResult = invokeMethod(methodName, paramTypes, params);
		
		assertEquals(actualResult, expectedResult);		
	}
	
	public void testUndo() {
		// undo add
		String actualResult = Execution.executeUndo();
		String expectedResult = Constant.MSG_UNDO_ADD_SUCCESS;
		
		int expectedSize = 0;
		int actualSize = Main.list.getTasks().size();
		
		assertEquals(actualSize, expectedSize);
		assertEquals(actualResult, expectedResult);
		
		// attempt to undo with an empty undo stack
		actualResult = Execution.executeUndo();
		expectedResult = Constant.MSG_NO_UNDO;
		
		assertEquals(actualResult, expectedResult);		
	}
	
	public void testRedo() {
		// redo add
		String actualResult = Execution.executeRedo();
		String expectedResult = Constant.MSG_REDO_ADD_SUCCESS;
				
		int expectedSize = 1;
		int actualSize = Main.list.getTasks().size();
				
		assertEquals(actualSize, expectedSize);
		assertEquals(actualResult, expectedResult);
			
		// attempt to redo with an empty redo stack
		actualResult = Execution.executeRedo();
		expectedResult = Constant.MSG_NO_REDO;
				
		assertEquals(actualResult, expectedResult);		
	}
	
	private String invokeMethod(String methodName, Class[] paramTypes, Object[] params) {
		Execution execution = new Execution();
		Class exeClass = execution.getClass();
		Method method = null;
		
		Object object = null;
		try {
			method = exeClass.getDeclaredMethod(methodName, paramTypes);
			method.setAccessible(true);
			
			object = method.invoke(new Execution(), params);
		} catch (NoSuchMethodException | SecurityException |
				IllegalAccessException | IllegalArgumentException | 
				InvocationTargetException e) {
			e.printStackTrace();
		} 
		
		return String.valueOf(object);
	}
	
	private void invokeMainPrivateMethod(String methodName) {
		Main main = new Main();
		Class mainClass = main.getClass();
		Method method = null;
		
		try {
			method = mainClass.getDeclaredMethod(methodName);
			method.setAccessible(true);
			
			method.invoke(ToDoList.class);
		} catch (NoSuchMethodException | SecurityException |
				IllegalAccessException | IllegalArgumentException | 
				InvocationTargetException e) {
			e.printStackTrace();
		} 
	}
	
	private void initTest() {
		String methodName = "initialise";		
		invokeMainPrivateMethod(methodName);		
		
		boolean isTest = true;
		originalSavePath = Main.list.getListFilePath();				
		
		// change save path in setting to 
		// point to the testfile		
		Main.storage.updateFilePathInSetting(ToDoListTest.PATH_TEST_FILE);		
		Main.list = new ToDoList(isTest);
	}
	
	private void cleanTestFromSystem() {
		deleteTestFile();
		Main.storage.updateFilePathInSetting(Constant.PATH_DEFAULT);
	}
	
	private void deleteTestFile() {
		File file = new File(ToDoListTest.PATH_TEST_FILE);
		file.delete();		
	}
}

	// End of segment: C:\Users\Ruyi\Desktop\collate\source\test\ExecutionTest.java





	/**
	 * origin: C:\Users\Ruyi\Desktop\collate\source\test\ToDoListTest.java
	 */

package test;

import static org.junit.Assert.*;

import java.io.File;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.ArrayList;

import javafx.util.Pair;

import org.junit.Test;
import org.w3c.dom.Document;
import org.w3c.dom.Node;

import application.Main;
import application.Task;
import application.ToDoList;

public class ToDoListTest {
	private static final String METHOD_NAME_INIT = "initialise";
	private static final String TEST_ADD_COMMAND = "Have dinner with Amy /on Monday //friend /*";
	private static final String TEST_DELETE_COMMAND = "delete 1";
	private static final String TEST_UPDATE_COMMAND = "update 1: Have dinner with Amy /by Monday //friend /*";
	private static final String TEST_UPDATE_COMMAND_NOT_FOUND = "update 1: Have dinner with Amy /by Monday //friend /*";
	public static final String PATH_TEST_FILE = "testFile.xml";
	
	private String originalSavePath;
	
	@Test 
	public void test() {
		initTest();		
		testAddTaskToList();
		testUpdateTaskOnList();
		testDeleteTaskFromList();
		
		cleanTestFromSystem();
	}
	
	public void testAddTaskToList() {		
		Task testTask = new Task(ToDoListTest.TEST_ADD_COMMAND);		
		int expectedSize = Main.list.getTasks().size() + 1;
		
		Main.list.addTaskToList(testTask);
		
		// Check size
		// The new task is only added into the arraylist 
		// when it has received a success message from storage
		// thus it is sufficient to check the size of tasks arraylist 
		int afterSize = Main.list.getTasks().size();
		assertEquals(afterSize, expectedSize);
	}

	/*
	 * Equivalence Partition: EXISTING_TASK, NON_EXISTING_TASK
	 * userInput: "delete d1", "delete d1" (after delete)
	 * Delete Result: DELETED: (size == size + 1) && removedTask != null, 
	 * 				  NOT_FOUND: (size == size) && removedTask == null
	 */
	public void testDeleteTaskFromList() {
		int expectedSize = Main.list.getTasks().size() - 1;		
		Pair<Task, String> deleteDetailsPair = 
				Main.list.deleteTaskFromList(ToDoListTest.TEST_DELETE_COMMAND);
		Task removedTask = deleteDetailsPair.getKey();
		
		// Check that task is removed
		assertNotNull(removedTask);
		
		// Check size
		int afterSize = Main.list.getTasks().size();
		assertEquals(afterSize, expectedSize);
		
		// Delete the same item again
		expectedSize = afterSize;
		deleteDetailsPair = Main.list.deleteTaskFromList(ToDoListTest.TEST_DELETE_COMMAND);
		removedTask = deleteDetailsPair.getKey();
		
		// Check that task is not found
		assertNull(removedTask);	
		// Check size
		afterSize = Main.list.getTasks().size();		
		assertEquals(afterSize, expectedSize);
	}

	/*
	 * Equivalence Partition: EXISTING_TASK, NON_EXISTING_TASK
	 * userInput: "update e1: <description>", "update d1: <description>"
	 * Delete Result: UPDATED: (id = e1) && resultPair != null, 
	 * 				  NOT_FOUND: resultPair == null
	 */
	public void testUpdateTaskOnList() {				
		Pair<Task, String> resultPair = 
				Main.list.updateTaskOnList(ToDoListTest.TEST_UPDATE_COMMAND);
		
		// Check that update has been done
		assertNotNull(resultPair);	
				
		//---------------------------------------------------------------------------------
		resultPair = Main.list.updateTaskOnList(ToDoListTest.
					TEST_UPDATE_COMMAND_NOT_FOUND);
		
		// Check that task not found
		assertNotNull(resultPair);	
	}
	
	private void initTest() {
		String methodName = ToDoListTest.METHOD_NAME_INIT;		
		invokeMainPrivateMethod(methodName);		
		
		boolean isTest = true;
		originalSavePath = Main.list.getListFilePath();				
		
		// change save path in setting to 
		// point to the testfile		
		Main.storage.updateFilePathInSetting(ToDoListTest.PATH_TEST_FILE);		
		Main.list = new ToDoList(isTest);
	}
	
	private void cleanTestFromSystem() {
		deleteTestFile();
		Main.storage.updateFilePathInSetting(originalSavePath);
	}
	
	private void deleteTestFile() {
		File file = new File(ToDoListTest.PATH_TEST_FILE);
		file.delete();		
	}
	
	private void invokeMainPrivateMethod(String methodName) {
		Main main = new Main();
		Class mainClass = main.getClass();
		Method method = null;
		
		try {
			method = mainClass.getDeclaredMethod(methodName);
			method.setAccessible(true);
			
			method.invoke(ToDoList.class);
		} catch (NoSuchMethodException | SecurityException |
				IllegalAccessException | IllegalArgumentException | 
				InvocationTargetException e) {
			e.printStackTrace();
		} 
	}

}

	// End of segment: C:\Users\Ruyi\Desktop\collate\source\test\ToDoListTest.java





